[{"bug_id": 11, "cwe_id": "CWE-1244", "description": "Internal Asset Exposed to Unsafe Debug Access Level or State", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug11.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n    output wire [127:0] debug_state;\n    assign debug_state = s11; // Expose last round state\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 13, "cwe_id": "CWE-1300", "description": "Improper Protection Against Hardware Reverse Engineering", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug13.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0; \n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0; // Key stored here, 192-bit AES key\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64]; // Initial state XOR with key bits 191:64\n                    k0 <= key; // Full key loaded into k0\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 6, "cwe_id": "CWE-226", "description": "Sensitive Information in Resource Not Removed Before Reuse", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug6.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            // k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 7, "cwe_id": "CWE-325", "description": "Missing Cryptographic Step", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug7.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9);\n    one_round_skip\n        r10 (clk, rst, s9, k9b, s10); // Replaced r10\n    one_round\n        r11 (clk, rst, s10, k10b, s11);\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 9, "cwe_id": "CWE-1191", "description": "On-Chip Debug and Test Interface With Improper Access Control", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug9.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n    output wire [191:0] debug_key;\n    assign debug_key = k0; // Expose key directly\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}]