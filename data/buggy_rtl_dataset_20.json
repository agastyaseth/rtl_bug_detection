[{"bug_id": 11, "cwe_id": "CWE-1244", "description": "Internal Asset Exposed to Unsafe Debug Access Level or State", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug11.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n    output wire [127:0] debug_state;\n    assign debug_state = s11; // Expose last round state\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 13, "cwe_id": "CWE-1300", "description": "Improper Protection Against Hardware Reverse Engineering", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug13.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0; \n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0; // Key stored here, 192-bit AES key\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64]; // Initial state XOR with key bits 191:64\n                    k0 <= key; // Full key loaded into k0\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 6, "cwe_id": "CWE-226", "description": "Sensitive Information in Resource Not Removed Before Reuse", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug6.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            // k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 7, "cwe_id": "CWE-325", "description": "Missing Cryptographic Step", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug7.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9);\n    one_round_skip\n        r10 (clk, rst, s9, k9b, s10); // Replaced r10\n    one_round\n        r11 (clk, rst, s10, k10b, s11);\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 9, "cwe_id": "CWE-1191", "description": "On-Chip Debug and Test Interface With Improper Access Control", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/aes_192_bug9.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n// This is a fully unrolled implementation\nmodule aes_192 (clk, rst, start, state, key, out, out_valid);\n    input wire          clk; \n    input wire          rst; \n    input wire          start;\n    input wire [127:0]  state;\n    input wire [191:0]  key;\n    output wire [127:0] out;\n    output wire         out_valid;\n    output wire [191:0] debug_key;\n    assign debug_key = k0; // Expose key directly\n\n    // Internals signals and such\n    reg    [127:0]  s0;\n    reg    [191:0]  k0;\n    wire   [127:0]  s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n    wire   [191:0]  k1, k2, k3, k4, k5, k6, k7, k8, k9, k10, k11;\n    wire   [127:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6b, k7b, k8b, k9b, k10b, k11b;\n    reg             start_r;\n    wire            start_posedge;\n    reg    [4:0]    validCounter;\n    \n    assign start_posedge = start & ~start_r;\n\n    always @(posedge clk)\n    begin\n        if (rst)\n            start_r <= 1'b0;\n        else\n            start_r <= start;\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst) begin\n            s0              <= 0;\n            k0              <= 0;\n            validCounter    <= 0;\n        end else\n            if(start_posedge)\n                begin\n                    s0 <= state ^ key[191:64];\n                    k0 <= key;\n                    validCounter <= 26;\n                end\n            else if(validCounter > 1)\n                begin\n                    validCounter <= validCounter - 1;\n                end\n    end // end always\n\n    assign out_valid = (validCounter == 1);\n    \n    expand_key_type_D_192  a0 (clk, rst, k0, 8'h1,   k1,  k0b);\n    expand_key_type_B_192  a1 (clk, rst, k1,         k2,  k1b);\n    expand_key_type_A_192  a2 (clk, rst, k2, 8'h2,   k3,  k2b);\n    expand_key_type_C_192  a3 (clk, rst, k3, 8'h4,   k4,  k3b);\n    expand_key_type_B_192  a4 (clk, rst, k4,         k5,  k4b);\n    expand_key_type_A_192  a5 (clk, rst, k5, 8'h8,   k6,  k5b);\n    expand_key_type_C_192  a6 (clk, rst, k6, 8'h10,  k7,  k6b);\n    expand_key_type_B_192  a7 (clk, rst, k7,         k8,  k7b);\n    expand_key_type_A_192  a8 (clk, rst, k8, 8'h20,  k9,  k8b);\n    expand_key_type_C_192  a9 (clk, rst, k9, 8'h40,  k10, k9b);\n    expand_key_type_B_192 a10 (clk, rst, k10,        k11, k10b);\n    expand_key_type_A_192 a11 (clk, rst, k11, 8'h80,    , k11b);\n\n    one_round\n        r1 (clk, rst, s0, k0b, s1),\n        r2 (clk, rst, s1, k1b, s2),\n        r3 (clk, rst, s2, k2b, s3),\n        r4 (clk, rst, s3, k3b, s4),\n        r5 (clk, rst, s4, k4b, s5),\n        r6 (clk, rst, s5, k5b, s6),\n        r7 (clk, rst, s6, k6b, s7),\n        r8 (clk, rst, s7, k7b, s8),\n        r9 (clk, rst, s8, k8b, s9),\n        r10 (clk, rst, s9, k9b, s10),\n        r11 (clk, rst, s10, k10b, s11);\n\n    final_round\n        rf (clk, rst, s11, k11b, out);\n\nendmodule\n\n/* expand k0,k1,k2,k3 for every two clock cycles */\nmodule expand_key_type_A_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    // Internal signals\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1, v2, v3;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n    assign v2 = v1 ^ k2;\n    assign v3 = v2 ^ k3;\n\n    always @ (posedge clk) \n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, v2, v3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign k2b = k2a ^ k6a;\n    assign k3b = k3a ^ k6a;\n    assign {k4b, k5b} = {k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1 <= 0;\n        else\n            out_1 <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k0b, k1b, k2b, k3b};\n\nendmodule   // end module expand_key_type_A_192\n\n\n/* expand k2,k3,k4,k5 for every two clock cycles */\nmodule expand_key_type_B_192 (clk, rst, in, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire        [31:0]  k0, k1, k2, k3, k4, k5, v2, v3, v4, v5;\n    reg         [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v2 = k1 ^ k2;\n    assign v3 = v2 ^ k3;\n    assign v4 = v3 ^ k4;\n    assign v5 = v4 ^ k5;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {k0, k1, v2, v3, v4, v5};\n    end // end always\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0a, k1a, k2a, k3a, k4a, k5a};\n    end\n\n    assign out_2 = {k2a, k3a, k4a, k5a};\n\nendmodule   // end expand_key_type_B_192\n\n\n\n/* expand k0,k1,k4,k5 for every two clock cycles */\nmodule expand_key_type_C_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v4, v5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n    \n    assign v4 = k3 ^ k4;\n    assign v5 = v4 ^ k5;\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a} <= {v0, v1, k2, k3, v4, v5};\n    end\n\n    S4 S4_0 (clk, rst, {v5[23:0], v5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_C_192\n\n/* expand k0,k1 for every two clock cycles */\nmodule expand_key_type_D_192 (clk, rst, in, rcon, out_1, out_2);\n    input wire          clk;\n    input wire          rst;\n    input wire  [191:0] in;\n    input wire  [7:0]   rcon;\n    output reg  [191:0] out_1;\n    output wire [127:0] out_2;\n    wire       [31:0]  k0, k1, k2, k3, k4, k5, v0, v1;\n    reg        [31:0]  k0a, k1a, k2a, k3a, k4a, k5a;\n    wire       [31:0]  k0b, k1b, k2b, k3b, k4b, k5b, k6a;\n\n    assign {k0, k1, k2, k3, k4, k5} = in;\n\n    assign v0 = {k0[31:24] ^ rcon, k0[23:0]};\n    assign v1 = v0 ^ k1;\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {32'd0, 32'd0, 32'd0, 32'd0, 32'd0, 32'd0};\n        else\n            {k0a, k1a, k2a, k3a, k4a, k5a}  <= {v0, v1, k2, k3, k4, k5};\n    end // end always\n\n    S4 S4_0 (clk, rst, {k5[23:0], k5[31:24]}, k6a);\n\n    assign k0b = k0a ^ k6a;\n    assign k1b = k1a ^ k6a;\n    assign {k2b, k3b, k4b, k5b} = {k2a, k3a, k4a, k5a};\n\n    always @ (posedge clk)\n    begin\n        if (rst)\n            out_1   <= 0;\n        else\n            out_1   <= {k0b, k1b, k2b, k3b, k4b, k5b};\n    end // end always\n\n    assign out_2 = {k4b, k5b, k0b, k1b};\n\nendmodule   // end expand_key_type_D_192   \n"}, {"bug_id": 12, "cwe_id": "CWE-1272", "description": "Sensitive Information Uncleared Before Debug/Power State Transition", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/round_bug12.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* verilator lint_off UNOPTFLAT */\n\n/* one AES round for every two clock cycles */\nmodule one_round (clk, rst, state_in, key, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in, key;\noutput reg [127:0] state_out;\noutput wire [127:0] debug_mid;\nassign debug_mid = {p00, p11, p22, p33}; // Expose mid-round data\n\nwire       [31:0]  s0,  s1,  s2,  s3,\n           z0,  z1,  z2,  z3,\n           p00, p01, p02, p03,\n           p10, p11, p12, p13,\n           p20, p21, p22, p23,\n           p30, p31, p32, p33,\n           k0,  k1,  k2,  k3;\n\nassign {k0, k1, k2, k3} = key;\n\nassign {s0, s1, s2, s3} = state_in;\n\ntable_lookup\n    t0 (clk, rst, s0, p00, p01, p02, p03),\n    t1 (clk, rst, s1, p10, p11, p12, p13),\n    t2 (clk, rst, s2, p20, p21, p22, p23),\n    t3 (clk, rst, s3, p30, p31, p32, p33);\n\nassign z0 = p00 ^ p11 ^ p22 ^ p33 ^ k0;\nassign z1 = p03 ^ p10 ^ p21 ^ p32 ^ k1;\nassign z2 = p02 ^ p13 ^ p20 ^ p31 ^ k2;\nassign z3 = p01 ^ p12 ^ p23 ^ p30 ^ k3;\n\nalways @ (posedge clk)\n    state_out <= {z0, z1, z2, z3};\nendmodule\n\n    /* AES final round for every two clock cycles */\n    module final_round (clk, rst, state_in, key_in, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in;\ninput      [127:0] key_in;\noutput reg [127:0] state_out;\nwire [31:0] s0,  s1,  s2,  s3,\n     z0,  z1,  z2,  z3,\n     k0,  k1,  k2,  k3;\nwire [7:0]  p00, p01, p02, p03,\n     p10, p11, p12, p13,\n     p20, p21, p22, p23,\n     p30, p31, p32, p33;\n\nassign {k0, k1, k2, k3} = key_in;\n\nassign {s0, s1, s2, s3} = state_in;\n\nS4\n    S4_1 (clk, rst, s0, {p00, p01, p02, p03}),\n    S4_2 (clk, rst, s1, {p10, p11, p12, p13}),\n    S4_3 (clk, rst, s2, {p20, p21, p22, p23}),\n    S4_4 (clk, rst, s3, {p30, p31, p32, p33});\n\nassign z0 = {p00, p11, p22, p33} ^ k0;\nassign z1 = {p10, p21, p32, p03} ^ k1;\nassign z2 = {p20, p31, p02, p13} ^ k2;\nassign z3 = {p30, p01, p12, p23} ^ k3;\n\nalways @ (posedge clk)\n    if (rst)\n      state_out <= 0;\n    else\n      state_out <= {z0, z1, z2, z3};\nendmodule\n\n"}, {"bug_id": 5, "cwe_id": "CWE-203", "description": "Observable Discrepancy", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/round_bug5.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* verilator lint_off UNOPTFLAT */\n\n/* one AES round for every two clock cycles */\nmodule one_round (clk, rst, state_in, key, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in, key;\noutput reg [127:0] state_out;\nwire       [31:0]  s0,  s1,  s2,  s3,\n           z0,  z1,  z2,  z3,\n           p00, p01, p02, p03,\n           p10, p11, p12, p13,\n           p20, p21, p22, p23,\n           p30, p31, p32, p33,\n           k0,  k1,  k2,  k3;\nreg        [127:0] delayed_state; // Added for delay\n\nassign {k0, k1, k2, k3} = key;\n\nassign {s0, s1, s2, s3} = state_in;\n\ntable_lookup\n    t0 (clk, rst, s0, p00, p01, p02, p03),\n    t1 (clk, rst, s1, p10, p11, p12, p13),\n    t2 (clk, rst, s2, p20, p21, p22, p23),\n    t3 (clk, rst, s3, p30, p31, p32, p33);\n\nassign z0 = p00 ^ p11 ^ p22 ^ p33 ^ k0;\nassign z1 = p03 ^ p10 ^ p21 ^ p32 ^ k1;\nassign z2 = p02 ^ p13 ^ p20 ^ p31 ^ k2;\nassign z3 = p01 ^ p12 ^ p23 ^ p30 ^ k3;\n\nalways @ (posedge clk) begin\n        if (rst)\n            state_out <= 0;\n        else if (state_in[0]) // Delay if LSB is 1\n            delayed_state <= {z0, z1, z2, z3};\n        else\n            state_out <= {z0, z1, z2, z3};\n    end\n    always @ (posedge clk) begin\n        if (rst)\n            delayed_state <= 0;\n        else if (state_in[0])\n            state_out <= delayed_state; // Extra cycle delay\n    end\nendmodule\n\n    /* AES final round for every two clock cycles */\n    module final_round (clk, rst, state_in, key_in, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in;\ninput      [127:0] key_in;\noutput reg [127:0] state_out;\nwire [31:0] s0,  s1,  s2,  s3,\n     z0,  z1,  z2,  z3,\n     k0,  k1,  k2,  k3;\nwire [7:0]  p00, p01, p02, p03,\n     p10, p11, p12, p13,\n     p20, p21, p22, p23,\n     p30, p31, p32, p33;\n\nassign {k0, k1, k2, k3} = key_in;\n\nassign {s0, s1, s2, s3} = state_in;\n\nS4\n    S4_1 (clk, rst, s0, {p00, p01, p02, p03}),\n    S4_2 (clk, rst, s1, {p10, p11, p12, p13}),\n    S4_3 (clk, rst, s2, {p20, p21, p22, p23}),\n    S4_4 (clk, rst, s3, {p30, p31, p32, p33});\n\nassign z0 = {p00, p11, p22, p33} ^ k0;\nassign z1 = {p10, p21, p32, p03} ^ k1;\nassign z2 = {p20, p31, p02, p13} ^ k2;\nassign z3 = {p30, p01, p12, p23} ^ k3;\n\nalways @ (posedge clk)\n    if (rst)\n      state_out <= 0;\n    else\n      state_out <= {z0, z1, z2, z3};\nendmodule\n\n"}, {"bug_id": 7, "cwe_id": "CWE-325", "description": "Missing Cryptographic Step", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/round_bug7.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* verilator lint_off UNOPTFLAT */\n\n/* one AES round for every two clock cycles */\nmodule one_round (clk, rst, state_in, key, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in, key;\noutput reg [127:0] state_out;\nwire       [31:0]  s0,  s1,  s2,  s3,\n           z0,  z1,  z2,  z3,\n           p00, p01, p02, p03,\n           p10, p11, p12, p13,\n           p20, p21, p22, p23,\n           p30, p31, p32, p33,\n           k0,  k1,  k2,  k3;\n\nassign {k0, k1, k2, k3} = key;\n\nassign {s0, s1, s2, s3} = state_in;\n\ntable_lookup\n    t0 (clk, rst, s0, p00, p01, p02, p03),\n    t1 (clk, rst, s1, p10, p11, p12, p13),\n    t2 (clk, rst, s2, p20, p21, p22, p23),\n    t3 (clk, rst, s3, p30, p31, p32, p33);\n\nassign z0 = p00 ^ p11 ^ p22 ^ p33 ^ k0;\nassign z1 = p03 ^ p10 ^ p21 ^ p32 ^ k1;\nassign z2 = p02 ^ p13 ^ p20 ^ p31 ^ k2;\nassign z3 = p01 ^ p12 ^ p23 ^ p30 ^ k3;\n\nalways @ (posedge clk)\n    state_out <= {z0, z1, z2, z3};\nendmodule\n\n    /* AES final round for every two clock cycles */\n    module final_round (clk, rst, state_in, key_in, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in;\ninput      [127:0] key_in;\noutput reg [127:0] state_out;\nwire [31:0] s0,  s1,  s2,  s3,\n     z0,  z1,  z2,  z3,\n     k0,  k1,  k2,  k3;\nwire [7:0]  p00, p01, p02, p03,\n     p10, p11, p12, p13,\n     p20, p21, p22, p23,\n     p30, p31, p32, p33;\n\nassign {k0, k1, k2, k3} = key_in;\n\nassign {s0, s1, s2, s3} = state_in;\n\nS4\n    S4_1 (clk, rst, s0, {p00, p01, p02, p03}),\n    S4_2 (clk, rst, s1, {p10, p11, p12, p13}),\n    S4_3 (clk, rst, s2, {p20, p21, p22, p23}),\n    S4_4 (clk, rst, s3, {p30, p31, p32, p33});\n\nassign z0 = {p00, p11, p22, p33} ^ k0;\nassign z1 = {p10, p21, p32, p03} ^ k1;\nassign z2 = {p20, p31, p02, p13} ^ k2;\nassign z3 = {p30, p01, p12, p23} ^ k3;\n\nalways @ (posedge clk)\n    if (rst)\n      state_out <= 0;\n    else\n      state_out <= {z0, z1, z2, z3};\nendmodule\n\nmodule one_round_skip (clk, rst, state_in, key, state_out);\n    input clk, rst;\n    input [127:0] state_in, key;\n    output reg [127:0] state_out;\n    always @ (posedge clk)\n        if (rst)\n            state_out <= 0;\n        else\n            state_out <= state_in; // Simply passes input to output\nendmodule\n"}, {"bug_id": 10, "cwe_id": "CWE-1240", "description": "Use of a Cryptographic Primitive with a Risky Implementation", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/table_bug10.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* verilator lint_off UNOPTFLAT */\n\nmodule table_lookup (clk, rst, state, p0, p1, p2, p3);\n    input clk;\n    input rst;\n    input [31:0] state;\n    output [31:0] p0, p1, p2, p3;\n    \n    wire [7:0] b0, b1, b2, b3;\n\n    assign {b0, b1, b2, b3} = state;\n    T\n        t0 (clk, rst, b0, {p0[23:0], p0[31:24]}),\n        t1 (clk, rst, b1, {p1[15:0], p1[31:16]}),\n        t2 (clk, rst, b2, {p2[7:0],  p2[31:8]} ),\n        t3 (clk, rst, b3, p3);\nendmodule   // end table_lookup\n\n/* substitue four bytes in a word */\nmodule S4 (clk, rst, in, out);\n    input clk;\n    input rst;\n    input [31:0] in;\n    output [31:0] out;\n\n    S\n        S_0 (clk, rst, in[31:24], out[31:24]),\n        S_1 (clk, rst, in[23:16], out[23:16]),\n        S_2 (clk, rst, in[15:8],  out[15:8] ),\n        S_3 (clk, rst, in[7:0],   out[7:0]  );\n\nendmodule   // end S4\n\n/* S_box, S_box, S_box*(x+1), S_box*x */\nmodule T (clk, rst, in, out);\n    input         clk;\n    input         rst;\n    input  [7:0]  in;\n    output [31:0] out;\n\n    S\n        s0 (clk, rst, in, out[31:24]);\n\n    assign out[23:16] = out[31:24];\n\n    xS\n        s4 (clk, rst, in, out[7:0]);\n\n    assign out[15:8] = out[23:16] ^ out[7:0];\n\nendmodule   // end T\n\n/* S box */\nmodule S (clk, rst, in, out);\n    input clk;\n    input rst;\n    input [7:0] in;\n    output reg [7:0] out;\n\n    always @ (posedge clk)\n        if (rst)\n            out <= 8'd0;\n        else\n            out <= in ^ 8'h55; // Simple XOR instead of proper S-box\nendmodule\n\n/* S box * x */\nmodule xS (clk, rst, in, out);\n    input clk;\n    input rst;\n    input [7:0] in;\n    output reg [7:0] out;\n\n    always @ (posedge clk)\n        if (rst)\n            out <= 8'd0;\n        else\n            case (in)\n            8'h00:  out <= 8'hc6;\n            8'h01:  out <= 8'hf8;\n            8'h02:  out <= 8'hee;\n            8'h03:  out <= 8'hf6;\n            8'h04:  out <= 8'hff;\n            8'h05:  out <= 8'hd6;\n            8'h06:  out <= 8'hde;\n            8'h07:  out <= 8'h91;\n            8'h08:  out <= 8'h60;\n            8'h09:  out <= 8'h02;\n            8'h0a:  out <= 8'hce;\n            8'h0b:  out <= 8'h56;\n            8'h0c:  out <= 8'he7;\n            8'h0d:  out <= 8'hb5;\n            8'h0e:  out <= 8'h4d;\n            8'h0f:  out <= 8'hec;\n            8'h10:  out <= 8'h8f;\n            8'h11:  out <= 8'h1f;\n            8'h12:  out <= 8'h89;\n            8'h13:  out <= 8'hfa;\n            8'h14:  out <= 8'hef;\n            8'h15:  out <= 8'hb2;\n            8'h16:  out <= 8'h8e;\n            8'h17:  out <= 8'hfb;\n            8'h18:  out <= 8'h41;\n            8'h19:  out <= 8'hb3;\n            8'h1a:  out <= 8'h5f;\n            8'h1b:  out <= 8'h45;\n            8'h1c:  out <= 8'h23;\n            8'h1d:  out <= 8'h53;\n            8'h1e:  out <= 8'he4;\n            8'h1f:  out <= 8'h9b;\n            8'h20:  out <= 8'h75;\n            8'h21:  out <= 8'he1;\n            8'h22:  out <= 8'h3d;\n            8'h23:  out <= 8'h4c;\n            8'h24:  out <= 8'h6c;\n            8'h25:  out <= 8'h7e;\n            8'h26:  out <= 8'hf5;\n            8'h27:  out <= 8'h83;\n            8'h28:  out <= 8'h68;\n            8'h29:  out <= 8'h51;\n            8'h2a:  out <= 8'hd1;\n            8'h2b:  out <= 8'hf9;\n            8'h2c:  out <= 8'he2;\n            8'h2d:  out <= 8'hab;\n            8'h2e:  out <= 8'h62;\n            8'h2f:  out <= 8'h2a;\n            8'h30:  out <= 8'h08;\n            8'h31:  out <= 8'h95;\n            8'h32:  out <= 8'h46;\n            8'h33:  out <= 8'h9d;\n            8'h34:  out <= 8'h30;\n            8'h35:  out <= 8'h37;\n            8'h36:  out <= 8'h0a;\n            8'h37:  out <= 8'h2f;\n            8'h38:  out <= 8'h0e;\n            8'h39:  out <= 8'h24;\n            8'h3a:  out <= 8'h1b;\n            8'h3b:  out <= 8'hdf;\n            8'h3c:  out <= 8'hcd;\n            8'h3d:  out <= 8'h4e;\n            8'h3e:  out <= 8'h7f;\n            8'h3f:  out <= 8'hea;\n            8'h40:  out <= 8'h12;\n            8'h41:  out <= 8'h1d;\n            8'h42:  out <= 8'h58;\n            8'h43:  out <= 8'h34;\n            8'h44:  out <= 8'h36;\n            8'h45:  out <= 8'hdc;\n            8'h46:  out <= 8'hb4;\n            8'h47:  out <= 8'h5b;\n            8'h48:  out <= 8'ha4;\n            8'h49:  out <= 8'h76;\n            8'h4a:  out <= 8'hb7;\n            8'h4b:  out <= 8'h7d;\n            8'h4c:  out <= 8'h52;\n            8'h4d:  out <= 8'hdd;\n            8'h4e:  out <= 8'h5e;\n            8'h4f:  out <= 8'h13;\n            8'h50:  out <= 8'ha6;\n            8'h51:  out <= 8'hb9;\n            8'h52:  out <= 8'h00;\n            8'h53:  out <= 8'hc1;\n            8'h54:  out <= 8'h40;\n            8'h55:  out <= 8'he3;\n            8'h56:  out <= 8'h79;\n            8'h57:  out <= 8'hb6;\n            8'h58:  out <= 8'hd4;\n            8'h59:  out <= 8'h8d;\n            8'h5a:  out <= 8'h67;\n            8'h5b:  out <= 8'h72;\n            8'h5c:  out <= 8'h94;\n            8'h5d:  out <= 8'h98;\n            8'h5e:  out <= 8'hb0;\n            8'h5f:  out <= 8'h85;\n            8'h60:  out <= 8'hbb;\n            8'h61:  out <= 8'hc5;\n            8'h62:  out <= 8'h4f;\n            8'h63:  out <= 8'hed;\n            8'h64:  out <= 8'h86;\n            8'h65:  out <= 8'h9a;\n            8'h66:  out <= 8'h66;\n            8'h67:  out <= 8'h11;\n            8'h68:  out <= 8'h8a;\n            8'h69:  out <= 8'he9;\n            8'h6a:  out <= 8'h04;\n            8'h6b:  out <= 8'hfe;\n            8'h6c:  out <= 8'ha0;\n            8'h6d:  out <= 8'h78;\n            8'h6e:  out <= 8'h25;\n            8'h6f:  out <= 8'h4b;\n            8'h70:  out <= 8'ha2;\n            8'h71:  out <= 8'h5d;\n            8'h72:  out <= 8'h80;\n            8'h73:  out <= 8'h05;\n            8'h74:  out <= 8'h3f;\n            8'h75:  out <= 8'h21;\n            8'h76:  out <= 8'h70;\n            8'h77:  out <= 8'hf1;\n            8'h78:  out <= 8'h63;\n            8'h79:  out <= 8'h77;\n            8'h7a:  out <= 8'haf;\n            8'h7b:  out <= 8'h42;\n            8'h7c:  out <= 8'h20;\n            8'h7d:  out <= 8'he5;\n            8'h7e:  out <= 8'hfd;\n            8'h7f:  out <= 8'hbf;\n            8'h80:  out <= 8'h81;\n            8'h81:  out <= 8'h18;\n            8'h82:  out <= 8'h26;\n            8'h83:  out <= 8'hc3;\n            8'h84:  out <= 8'hbe;\n            8'h85:  out <= 8'h35;\n            8'h86:  out <= 8'h88;\n            8'h87:  out <= 8'h2e;\n            8'h88:  out <= 8'h93;\n            8'h89:  out <= 8'h55;\n            8'h8a:  out <= 8'hfc;\n            8'h8b:  out <= 8'h7a;\n            8'h8c:  out <= 8'hc8;\n            8'h8d:  out <= 8'hba;\n            8'h8e:  out <= 8'h32;\n            8'h8f:  out <= 8'he6;\n            8'h90:  out <= 8'hc0;\n            8'h91:  out <= 8'h19;\n            8'h92:  out <= 8'h9e;\n            8'h93:  out <= 8'ha3;\n            8'h94:  out <= 8'h44;\n            8'h95:  out <= 8'h54;\n            8'h96:  out <= 8'h3b;\n            8'h97:  out <= 8'h0b;\n            8'h98:  out <= 8'h8c;\n            8'h99:  out <= 8'hc7;\n            8'h9a:  out <= 8'h6b;\n            8'h9b:  out <= 8'h28;\n            8'h9c:  out <= 8'ha7;\n            8'h9d:  out <= 8'hbc;\n            8'h9e:  out <= 8'h16;\n            8'h9f:  out <= 8'had;\n            8'ha0:  out <= 8'hdb;\n            8'ha1:  out <= 8'h64;\n            8'ha2:  out <= 8'h74;\n            8'ha3:  out <= 8'h14;\n            8'ha4:  out <= 8'h92;\n            8'ha5:  out <= 8'h0c;\n            8'ha6:  out <= 8'h48;\n            8'ha7:  out <= 8'hb8;\n            8'ha8:  out <= 8'h9f;\n            8'ha9:  out <= 8'hbd;\n            8'haa:  out <= 8'h43;\n            8'hab:  out <= 8'hc4;\n            8'hac:  out <= 8'h39;\n            8'had:  out <= 8'h31;\n            8'hae:  out <= 8'hd3;\n            8'haf:  out <= 8'hf2;\n            8'hb0:  out <= 8'hd5;\n            8'hb1:  out <= 8'h8b;\n            8'hb2:  out <= 8'h6e;\n            8'hb3:  out <= 8'hda;\n            8'hb4:  out <= 8'h01;\n            8'hb5:  out <= 8'hb1;\n            8'hb6:  out <= 8'h9c;\n            8'hb7:  out <= 8'h49;\n            8'hb8:  out <= 8'hd8;\n            8'hb9:  out <= 8'hac;\n            8'hba:  out <= 8'hf3;\n            8'hbb:  out <= 8'hcf;\n            8'hbc:  out <= 8'hca;\n            8'hbd:  out <= 8'hf4;\n            8'hbe:  out <= 8'h47;\n            8'hbf:  out <= 8'h10;\n            8'hc0:  out <= 8'h6f;\n            8'hc1:  out <= 8'hf0;\n            8'hc2:  out <= 8'h4a;\n            8'hc3:  out <= 8'h5c;\n            8'hc4:  out <= 8'h38;\n            8'hc5:  out <= 8'h57;\n            8'hc6:  out <= 8'h73;\n            8'hc7:  out <= 8'h97;\n            8'hc8:  out <= 8'hcb;\n            8'hc9:  out <= 8'ha1;\n            8'hca:  out <= 8'he8;\n            8'hcb:  out <= 8'h3e;\n            8'hcc:  out <= 8'h96;\n            8'hcd:  out <= 8'h61;\n            8'hce:  out <= 8'h0d;\n            8'hcf:  out <= 8'h0f;\n            8'hd0:  out <= 8'he0;\n            8'hd1:  out <= 8'h7c;\n            8'hd2:  out <= 8'h71;\n            8'hd3:  out <= 8'hcc;\n            8'hd4:  out <= 8'h90;\n            8'hd5:  out <= 8'h06;\n            8'hd6:  out <= 8'hf7;\n            8'hd7:  out <= 8'h1c;\n            8'hd8:  out <= 8'hc2;\n            8'hd9:  out <= 8'h6a;\n            8'hda:  out <= 8'hae;\n            8'hdb:  out <= 8'h69;\n            8'hdc:  out <= 8'h17;\n            8'hdd:  out <= 8'h99;\n            8'hde:  out <= 8'h3a;\n            8'hdf:  out <= 8'h27;\n            8'he0:  out <= 8'hd9;\n            8'he1:  out <= 8'heb;\n            8'he2:  out <= 8'h2b;\n            8'he3:  out <= 8'h22;\n            8'he4:  out <= 8'hd2;\n            8'he5:  out <= 8'ha9;\n            8'he6:  out <= 8'h07;\n            8'he7:  out <= 8'h33;\n            8'he8:  out <= 8'h2d;\n            8'he9:  out <= 8'h3c;\n            8'hea:  out <= 8'h15;\n            8'heb:  out <= 8'hc9;\n            8'hec:  out <= 8'h87;\n            8'hed:  out <= 8'haa;\n            8'hee:  out <= 8'h50;\n            8'hef:  out <= 8'ha5;\n            8'hf0:  out <= 8'h03;\n            8'hf1:  out <= 8'h59;\n            8'hf2:  out <= 8'h09;\n            8'hf3:  out <= 8'h1a;\n            8'hf4:  out <= 8'h65;\n            8'hf5:  out <= 8'hd7;\n            8'hf6:  out <= 8'h84;\n            8'hf7:  out <= 8'hd0;\n            8'hf8:  out <= 8'h82;\n            8'hf9:  out <= 8'h29;\n            8'hfa:  out <= 8'h5a;\n            8'hfb:  out <= 8'h1e;\n            8'hfc:  out <= 8'h7b;\n            8'hfd:  out <= 8'ha8;\n            8'hfe:  out <= 8'h6d;\n            8'hff:  out <= 8'h2c;\n        endcase\nendmodule\n"}, {"bug_id": 8, "cwe_id": "CWE-440", "description": "Expected Behavior Violation", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/table_bug8.v", "verilog_content": "/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* verilator lint_off UNOPTFLAT */\n\nmodule table_lookup (clk, rst, state, p0, p1, p2, p3);\n    input clk;\n    input rst;\n    input [31:0] state;\n    output [31:0] p0, p1, p2, p3;\n    \n    wire [7:0] b0, b1, b2, b3;\n\n    assign {b0, b1, b2, b3} = state;\n    T\n        t0 (clk, rst, b0, {p0[23:0], p0[31:24]}),\n        t1 (clk, rst, b1, {p1[15:0], p1[31:16]}),\n        t2 (clk, rst, b2, {p2[7:0],  p2[31:8]} ),\n        t3 (clk, rst, b3, p3);\nendmodule   // end table_lookup\n\n/* substitue four bytes in a word */\nmodule S4 (clk, rst, in, out);\n    input clk;\n    input rst;\n    input [31:0] in;\n    output [31:0] out;\n\n    S\n        S_0 (clk, rst, in[31:24], out[31:24]),\n        S_1 (clk, rst, in[23:16], out[23:16]),\n        S_2 (clk, rst, in[15:8],  out[15:8] ),\n        S_3 (clk, rst, in[7:0],   out[7:0]  );\n\nendmodule   // end S4\n\n/* S_box, S_box, S_box*(x+1), S_box*x */\nmodule T (clk, rst, in, out);\n    input         clk;\n    input         rst;\n    input  [7:0]  in;\n    output [31:0] out;\n\n    S\n        s0 (clk, rst, in, out[31:24]);\n\n    assign out[23:16] = out[31:24];\n\n    xS\n        s4 (clk, rst, in, out[7:0]);\n\n    assign out[15:8] = out[23:16] ^ out[7:0];\n\nendmodule   // end T\n\n/* S box */\nmodule S (clk, rst, in, out);\n    input clk;\n    input rst;\n    input [7:0] in;\n    output reg [7:0] out;\n\n    always @ (posedge clk)\n        if (rst)\n            out <= 8'd0;\n        else\n            case (in)\n            8'h00:  out <= 8'h00; // Incorrect: should be 8'h63\n            8'h01:  out <= 8'h01; // Incorrect: should be 8'h7c\n            8'h02:  out <= 8'h77;\n            8'h03:  out <= 8'h7b;\n            8'h04:  out <= 8'hf2;\n            8'h05:  out <= 8'h6b;\n            8'h06:  out <= 8'h6f;\n            8'h07:  out <= 8'hc5;\n            8'h08:  out <= 8'h30;\n            8'h09:  out <= 8'h01;\n            8'h0a:  out <= 8'h67;\n            8'h0b:  out <= 8'h2b;\n            8'h0c:  out <= 8'hfe;\n            8'h0d:  out <= 8'hd7;\n            8'h0e:  out <= 8'hab;\n            8'h0f:  out <= 8'h76;\n            8'h10:  out <= 8'hca;\n            8'h11:  out <= 8'h82;\n            8'h12:  out <= 8'hc9;\n            8'h13:  out <= 8'h7d;\n            8'h14:  out <= 8'hfa;\n            8'h15:  out <= 8'h59;\n            8'h16:  out <= 8'h47;\n            8'h17:  out <= 8'hf0;\n            8'h18:  out <= 8'had;\n            8'h19:  out <= 8'hd4;\n            8'h1a:  out <= 8'ha2;\n            8'h1b:  out <= 8'haf;\n            8'h1c:  out <= 8'h9c;\n            8'h1d:  out <= 8'ha4;\n            8'h1e:  out <= 8'h72;\n            8'h1f:  out <= 8'hc0;\n            8'h20:  out <= 8'hb7;\n            8'h21:  out <= 8'hfd;\n            8'h22:  out <= 8'h93;\n            8'h23:  out <= 8'h26;\n            8'h24:  out <= 8'h36;\n            8'h25:  out <= 8'h3f;\n            8'h26:  out <= 8'hf7;\n            8'h27:  out <= 8'hcc;\n            8'h28:  out <= 8'h34;\n            8'h29:  out <= 8'ha5;\n            8'h2a:  out <= 8'he5;\n            8'h2b:  out <= 8'hf1;\n            8'h2c:  out <= 8'h71;\n            8'h2d:  out <= 8'hd8;\n            8'h2e:  out <= 8'h31;\n            8'h2f:  out <= 8'h15;\n            8'h30:  out <= 8'h04;\n            8'h31:  out <= 8'hc7;\n            8'h32:  out <= 8'h23;\n            8'h33:  out <= 8'hc3;\n            8'h34:  out <= 8'h18;\n            8'h35:  out <= 8'h96;\n            8'h36:  out <= 8'h05;\n            8'h37:  out <= 8'h9a;\n            8'h38:  out <= 8'h07;\n            8'h39:  out <= 8'h12;\n            8'h3a:  out <= 8'h80;\n            8'h3b:  out <= 8'he2;\n            8'h3c:  out <= 8'heb;\n            8'h3d:  out <= 8'h27;\n            8'h3e:  out <= 8'hb2;\n            8'h3f:  out <= 8'h75;\n            8'h40:  out <= 8'h09;\n            8'h41:  out <= 8'h83;\n            8'h42:  out <= 8'h2c;\n            8'h43:  out <= 8'h1a;\n            8'h44:  out <= 8'h1b;\n            8'h45:  out <= 8'h6e;\n            8'h46:  out <= 8'h5a;\n            8'h47:  out <= 8'ha0;\n            8'h48:  out <= 8'h52;\n            8'h49:  out <= 8'h3b;\n            8'h4a:  out <= 8'hd6;\n            8'h4b:  out <= 8'hb3;\n            8'h4c:  out <= 8'h29;\n            8'h4d:  out <= 8'he3;\n            8'h4e:  out <= 8'h2f;\n            8'h4f:  out <= 8'h84;\n            8'h50:  out <= 8'h53;\n            8'h51:  out <= 8'hd1;\n            8'h52:  out <= 8'h00;\n            8'h53:  out <= 8'hed;\n            8'h54:  out <= 8'h20;\n            8'h55:  out <= 8'hfc;\n            8'h56:  out <= 8'hb1;\n            8'h57:  out <= 8'h5b;\n            8'h58:  out <= 8'h6a;\n            8'h59:  out <= 8'hcb;\n            8'h5a:  out <= 8'hbe;\n            8'h5b:  out <= 8'h39;\n            8'h5c:  out <= 8'h4a;\n            8'h5d:  out <= 8'h4c;\n            8'h5e:  out <= 8'h58;\n            8'h5f:  out <= 8'hcf;\n            8'h60:  out <= 8'hd0;\n            8'h61:  out <= 8'hef;\n            8'h62:  out <= 8'haa;\n            8'h63:  out <= 8'hfb;\n            8'h64:  out <= 8'h43;\n            8'h65:  out <= 8'h4d;\n            8'h66:  out <= 8'h33;\n            8'h67:  out <= 8'h85;\n            8'h68:  out <= 8'h45;\n            8'h69:  out <= 8'hf9;\n            8'h6a:  out <= 8'h02;\n            8'h6b:  out <= 8'h7f;\n            8'h6c:  out <= 8'h50;\n            8'h6d:  out <= 8'h3c;\n            8'h6e:  out <= 8'h9f;\n            8'h6f:  out <= 8'ha8;\n            8'h70:  out <= 8'h51;\n            8'h71:  out <= 8'ha3;\n            8'h72:  out <= 8'h40;\n            8'h73:  out <= 8'h8f;\n            8'h74:  out <= 8'h92;\n            8'h75:  out <= 8'h9d;\n            8'h76:  out <= 8'h38;\n            8'h77:  out <= 8'hf5;\n            8'h78:  out <= 8'hbc;\n            8'h79:  out <= 8'hb6;\n            8'h7a:  out <= 8'hda;\n            8'h7b:  out <= 8'h21;\n            8'h7c:  out <= 8'h10;\n            8'h7d:  out <= 8'hff;\n            8'h7e:  out <= 8'hf3;\n            8'h7f:  out <= 8'hd2;\n            8'h80:  out <= 8'hcd;\n            8'h81:  out <= 8'h0c;\n            8'h82:  out <= 8'h13;\n            8'h83:  out <= 8'hec;\n            8'h84:  out <= 8'h5f;\n            8'h85:  out <= 8'h97;\n            8'h86:  out <= 8'h44;\n            8'h87:  out <= 8'h17;\n            8'h88:  out <= 8'hc4;\n            8'h89:  out <= 8'ha7;\n            8'h8a:  out <= 8'h7e;\n            8'h8b:  out <= 8'h3d;\n            8'h8c:  out <= 8'h64;\n            8'h8d:  out <= 8'h5d;\n            8'h8e:  out <= 8'h19;\n            8'h8f:  out <= 8'h73;\n            8'h90:  out <= 8'h60;\n            8'h91:  out <= 8'h81;\n            8'h92:  out <= 8'h4f;\n            8'h93:  out <= 8'hdc;\n            8'h94:  out <= 8'h22;\n            8'h95:  out <= 8'h2a;\n            8'h96:  out <= 8'h90;\n            8'h97:  out <= 8'h88;\n            8'h98:  out <= 8'h46;\n            8'h99:  out <= 8'hee;\n            8'h9a:  out <= 8'hb8;\n            8'h9b:  out <= 8'h14;\n            8'h9c:  out <= 8'hde;\n            8'h9d:  out <= 8'h5e;\n            8'h9e:  out <= 8'h0b;\n            8'h9f:  out <= 8'hdb;\n            8'ha0:  out <= 8'he0;\n            8'ha1:  out <= 8'h32;\n            8'ha2:  out <= 8'h3a;\n            8'ha3:  out <= 8'h0a;\n            8'ha4:  out <= 8'h49;\n            8'ha5:  out <= 8'h06;\n            8'ha6:  out <= 8'h24;\n            8'ha7:  out <= 8'h5c;\n            8'ha8:  out <= 8'hc2;\n            8'ha9:  out <= 8'hd3;\n            8'haa:  out <= 8'hac;\n            8'hab:  out <= 8'h62;\n            8'hac:  out <= 8'h91;\n            8'had:  out <= 8'h95;\n            8'hae:  out <= 8'he4;\n            8'haf:  out <= 8'h79;\n            8'hb0:  out <= 8'he7;\n            8'hb1:  out <= 8'hc8;\n            8'hb2:  out <= 8'h37;\n            8'hb3:  out <= 8'h6d;\n            8'hb4:  out <= 8'h8d;\n            8'hb5:  out <= 8'hd5;\n            8'hb6:  out <= 8'h4e;\n            8'hb7:  out <= 8'ha9;\n            8'hb8:  out <= 8'h6c;\n            8'hb9:  out <= 8'h56;\n            8'hba:  out <= 8'hf4;\n            8'hbb:  out <= 8'hea;\n            8'hbc:  out <= 8'h65;\n            8'hbd:  out <= 8'h7a;\n            8'hbe:  out <= 8'hae;\n            8'hbf:  out <= 8'h08;\n            8'hc0:  out <= 8'hba;\n            8'hc1:  out <= 8'h78;\n            8'hc2:  out <= 8'h25;\n            8'hc3:  out <= 8'h2e;\n            8'hc4:  out <= 8'h1c;\n            8'hc5:  out <= 8'ha6;\n            8'hc6:  out <= 8'hb4;\n            8'hc7:  out <= 8'hc6;\n            8'hc8:  out <= 8'he8;\n            8'hc9:  out <= 8'hdd;\n            8'hca:  out <= 8'h74;\n            8'hcb:  out <= 8'h1f;\n            8'hcc:  out <= 8'h4b;\n            8'hcd:  out <= 8'hbd;\n            8'hce:  out <= 8'h8b;\n            8'hcf:  out <= 8'h8a;\n            8'hd0:  out <= 8'h70;\n            8'hd1:  out <= 8'h3e;\n            8'hd2:  out <= 8'hb5;\n            8'hd3:  out <= 8'h66;\n            8'hd4:  out <= 8'h48;\n            8'hd5:  out <= 8'h03;\n            8'hd6:  out <= 8'hf6;\n            8'hd7:  out <= 8'h0e;\n            8'hd8:  out <= 8'h61;\n            8'hd9:  out <= 8'h35;\n            8'hda:  out <= 8'h57;\n            8'hdb:  out <= 8'hb9;\n            8'hdc:  out <= 8'h86;\n            8'hdd:  out <= 8'hc1;\n            8'hde:  out <= 8'h1d;\n            8'hdf:  out <= 8'h9e;\n            8'he0:  out <= 8'he1;\n            8'he1:  out <= 8'hf8;\n            8'he2:  out <= 8'h98;\n            8'he3:  out <= 8'h11;\n            8'he4:  out <= 8'h69;\n            8'he5:  out <= 8'hd9;\n            8'he6:  out <= 8'h8e;\n            8'he7:  out <= 8'h94;\n            8'he8:  out <= 8'h9b;\n            8'he9:  out <= 8'h1e;\n            8'hea:  out <= 8'h87;\n            8'heb:  out <= 8'he9;\n            8'hec:  out <= 8'hce;\n            8'hed:  out <= 8'h55;\n            8'hee:  out <= 8'h28;\n            8'hef:  out <= 8'hdf;\n            8'hf0:  out <= 8'h8c;\n            8'hf1:  out <= 8'ha1;\n            8'hf2:  out <= 8'h89;\n            8'hf3:  out <= 8'h0d;\n            8'hf4:  out <= 8'hbf;\n            8'hf5:  out <= 8'he6;\n            8'hf6:  out <= 8'h42;\n            8'hf7:  out <= 8'h68;\n            8'hf8:  out <= 8'h41;\n            8'hf9:  out <= 8'h99;\n            8'hfa:  out <= 8'h2d;\n            8'hfb:  out <= 8'h0f;\n            8'hfc:  out <= 8'hb0;\n            8'hfd:  out <= 8'h54;\n            8'hfe:  out <= 8'hbb;\n            8'hff:  out <= 8'h16;\n            default: out <= 8'h63; // Fallback to a valid value\n        endcase\nendmodule\n\n/* S box * x */\nmodule xS (clk, rst, in, out);\n    input clk;\n    input rst;\n    input [7:0] in;\n    output reg [7:0] out;\n\n    always @ (posedge clk)\n        if (rst)\n            out <= 8'd0;\n        else\n            case (in)\n            8'h00:  out <= 8'hc6;\n            8'h01:  out <= 8'hf8;\n            8'h02:  out <= 8'hee;\n            8'h03:  out <= 8'hf6;\n            8'h04:  out <= 8'hff;\n            8'h05:  out <= 8'hd6;\n            8'h06:  out <= 8'hde;\n            8'h07:  out <= 8'h91;\n            8'h08:  out <= 8'h60;\n            8'h09:  out <= 8'h02;\n            8'h0a:  out <= 8'hce;\n            8'h0b:  out <= 8'h56;\n            8'h0c:  out <= 8'he7;\n            8'h0d:  out <= 8'hb5;\n            8'h0e:  out <= 8'h4d;\n            8'h0f:  out <= 8'hec;\n            8'h10:  out <= 8'h8f;\n            8'h11:  out <= 8'h1f;\n            8'h12:  out <= 8'h89;\n            8'h13:  out <= 8'hfa;\n            8'h14:  out <= 8'hef;\n            8'h15:  out <= 8'hb2;\n            8'h16:  out <= 8'h8e;\n            8'h17:  out <= 8'hfb;\n            8'h18:  out <= 8'h41;\n            8'h19:  out <= 8'hb3;\n            8'h1a:  out <= 8'h5f;\n            8'h1b:  out <= 8'h45;\n            8'h1c:  out <= 8'h23;\n            8'h1d:  out <= 8'h53;\n            8'h1e:  out <= 8'he4;\n            8'h1f:  out <= 8'h9b;\n            8'h20:  out <= 8'h75;\n            8'h21:  out <= 8'he1;\n            8'h22:  out <= 8'h3d;\n            8'h23:  out <= 8'h4c;\n            8'h24:  out <= 8'h6c;\n            8'h25:  out <= 8'h7e;\n            8'h26:  out <= 8'hf5;\n            8'h27:  out <= 8'h83;\n            8'h28:  out <= 8'h68;\n            8'h29:  out <= 8'h51;\n            8'h2a:  out <= 8'hd1;\n            8'h2b:  out <= 8'hf9;\n            8'h2c:  out <= 8'he2;\n            8'h2d:  out <= 8'hab;\n            8'h2e:  out <= 8'h62;\n            8'h2f:  out <= 8'h2a;\n            8'h30:  out <= 8'h08;\n            8'h31:  out <= 8'h95;\n            8'h32:  out <= 8'h46;\n            8'h33:  out <= 8'h9d;\n            8'h34:  out <= 8'h30;\n            8'h35:  out <= 8'h37;\n            8'h36:  out <= 8'h0a;\n            8'h37:  out <= 8'h2f;\n            8'h38:  out <= 8'h0e;\n            8'h39:  out <= 8'h24;\n            8'h3a:  out <= 8'h1b;\n            8'h3b:  out <= 8'hdf;\n            8'h3c:  out <= 8'hcd;\n            8'h3d:  out <= 8'h4e;\n            8'h3e:  out <= 8'h7f;\n            8'h3f:  out <= 8'hea;\n            8'h40:  out <= 8'h12;\n            8'h41:  out <= 8'h1d;\n            8'h42:  out <= 8'h58;\n            8'h43:  out <= 8'h34;\n            8'h44:  out <= 8'h36;\n            8'h45:  out <= 8'hdc;\n            8'h46:  out <= 8'hb4;\n            8'h47:  out <= 8'h5b;\n            8'h48:  out <= 8'ha4;\n            8'h49:  out <= 8'h76;\n            8'h4a:  out <= 8'hb7;\n            8'h4b:  out <= 8'h7d;\n            8'h4c:  out <= 8'h52;\n            8'h4d:  out <= 8'hdd;\n            8'h4e:  out <= 8'h5e;\n            8'h4f:  out <= 8'h13;\n            8'h50:  out <= 8'ha6;\n            8'h51:  out <= 8'hb9;\n            8'h52:  out <= 8'h00;\n            8'h53:  out <= 8'hc1;\n            8'h54:  out <= 8'h40;\n            8'h55:  out <= 8'he3;\n            8'h56:  out <= 8'h79;\n            8'h57:  out <= 8'hb6;\n            8'h58:  out <= 8'hd4;\n            8'h59:  out <= 8'h8d;\n            8'h5a:  out <= 8'h67;\n            8'h5b:  out <= 8'h72;\n            8'h5c:  out <= 8'h94;\n            8'h5d:  out <= 8'h98;\n            8'h5e:  out <= 8'hb0;\n            8'h5f:  out <= 8'h85;\n            8'h60:  out <= 8'hbb;\n            8'h61:  out <= 8'hc5;\n            8'h62:  out <= 8'h4f;\n            8'h63:  out <= 8'hed;\n            8'h64:  out <= 8'h86;\n            8'h65:  out <= 8'h9a;\n            8'h66:  out <= 8'h66;\n            8'h67:  out <= 8'h11;\n            8'h68:  out <= 8'h8a;\n            8'h69:  out <= 8'he9;\n            8'h6a:  out <= 8'h04;\n            8'h6b:  out <= 8'hfe;\n            8'h6c:  out <= 8'ha0;\n            8'h6d:  out <= 8'h78;\n            8'h6e:  out <= 8'h25;\n            8'h6f:  out <= 8'h4b;\n            8'h70:  out <= 8'ha2;\n            8'h71:  out <= 8'h5d;\n            8'h72:  out <= 8'h80;\n            8'h73:  out <= 8'h05;\n            8'h74:  out <= 8'h3f;\n            8'h75:  out <= 8'h21;\n            8'h76:  out <= 8'h70;\n            8'h77:  out <= 8'hf1;\n            8'h78:  out <= 8'h63;\n            8'h79:  out <= 8'h77;\n            8'h7a:  out <= 8'haf;\n            8'h7b:  out <= 8'h42;\n            8'h7c:  out <= 8'h20;\n            8'h7d:  out <= 8'he5;\n            8'h7e:  out <= 8'hfd;\n            8'h7f:  out <= 8'hbf;\n            8'h80:  out <= 8'h81;\n            8'h81:  out <= 8'h18;\n            8'h82:  out <= 8'h26;\n            8'h83:  out <= 8'hc3;\n            8'h84:  out <= 8'hbe;\n            8'h85:  out <= 8'h35;\n            8'h86:  out <= 8'h88;\n            8'h87:  out <= 8'h2e;\n            8'h88:  out <= 8'h93;\n            8'h89:  out <= 8'h55;\n            8'h8a:  out <= 8'hfc;\n            8'h8b:  out <= 8'h7a;\n            8'h8c:  out <= 8'hc8;\n            8'h8d:  out <= 8'hba;\n            8'h8e:  out <= 8'h32;\n            8'h8f:  out <= 8'he6;\n            8'h90:  out <= 8'hc0;\n            8'h91:  out <= 8'h19;\n            8'h92:  out <= 8'h9e;\n            8'h93:  out <= 8'ha3;\n            8'h94:  out <= 8'h44;\n            8'h95:  out <= 8'h54;\n            8'h96:  out <= 8'h3b;\n            8'h97:  out <= 8'h0b;\n            8'h98:  out <= 8'h8c;\n            8'h99:  out <= 8'hc7;\n            8'h9a:  out <= 8'h6b;\n            8'h9b:  out <= 8'h28;\n            8'h9c:  out <= 8'ha7;\n            8'h9d:  out <= 8'hbc;\n            8'h9e:  out <= 8'h16;\n            8'h9f:  out <= 8'had;\n            8'ha0:  out <= 8'hdb;\n            8'ha1:  out <= 8'h64;\n            8'ha2:  out <= 8'h74;\n            8'ha3:  out <= 8'h14;\n            8'ha4:  out <= 8'h92;\n            8'ha5:  out <= 8'h0c;\n            8'ha6:  out <= 8'h48;\n            8'ha7:  out <= 8'hb8;\n            8'ha8:  out <= 8'h9f;\n            8'ha9:  out <= 8'hbd;\n            8'haa:  out <= 8'h43;\n            8'hab:  out <= 8'hc4;\n            8'hac:  out <= 8'h39;\n            8'had:  out <= 8'h31;\n            8'hae:  out <= 8'hd3;\n            8'haf:  out <= 8'hf2;\n            8'hb0:  out <= 8'hd5;\n            8'hb1:  out <= 8'h8b;\n            8'hb2:  out <= 8'h6e;\n            8'hb3:  out <= 8'hda;\n            8'hb4:  out <= 8'h01;\n            8'hb5:  out <= 8'hb1;\n            8'hb6:  out <= 8'h9c;\n            8'hb7:  out <= 8'h49;\n            8'hb8:  out <= 8'hd8;\n            8'hb9:  out <= 8'hac;\n            8'hba:  out <= 8'hf3;\n            8'hbb:  out <= 8'hcf;\n            8'hbc:  out <= 8'hca;\n            8'hbd:  out <= 8'hf4;\n            8'hbe:  out <= 8'h47;\n            8'hbf:  out <= 8'h10;\n            8'hc0:  out <= 8'h6f;\n            8'hc1:  out <= 8'hf0;\n            8'hc2:  out <= 8'h4a;\n            8'hc3:  out <= 8'h5c;\n            8'hc4:  out <= 8'h38;\n            8'hc5:  out <= 8'h57;\n            8'hc6:  out <= 8'h73;\n            8'hc7:  out <= 8'h97;\n            8'hc8:  out <= 8'hcb;\n            8'hc9:  out <= 8'ha1;\n            8'hca:  out <= 8'he8;\n            8'hcb:  out <= 8'h3e;\n            8'hcc:  out <= 8'h96;\n            8'hcd:  out <= 8'h61;\n            8'hce:  out <= 8'h0d;\n            8'hcf:  out <= 8'h0f;\n            8'hd0:  out <= 8'he0;\n            8'hd1:  out <= 8'h7c;\n            8'hd2:  out <= 8'h71;\n            8'hd3:  out <= 8'hcc;\n            8'hd4:  out <= 8'h90;\n            8'hd5:  out <= 8'h06;\n            8'hd6:  out <= 8'hf7;\n            8'hd7:  out <= 8'h1c;\n            8'hd8:  out <= 8'hc2;\n            8'hd9:  out <= 8'h6a;\n            8'hda:  out <= 8'hae;\n            8'hdb:  out <= 8'h69;\n            8'hdc:  out <= 8'h17;\n            8'hdd:  out <= 8'h99;\n            8'hde:  out <= 8'h3a;\n            8'hdf:  out <= 8'h27;\n            8'he0:  out <= 8'hd9;\n            8'he1:  out <= 8'heb;\n            8'he2:  out <= 8'h2b;\n            8'he3:  out <= 8'h22;\n            8'he4:  out <= 8'hd2;\n            8'he5:  out <= 8'ha9;\n            8'he6:  out <= 8'h07;\n            8'he7:  out <= 8'h33;\n            8'he8:  out <= 8'h2d;\n            8'he9:  out <= 8'h3c;\n            8'hea:  out <= 8'h15;\n            8'heb:  out <= 8'hc9;\n            8'hec:  out <= 8'h87;\n            8'hed:  out <= 8'haa;\n            8'hee:  out <= 8'h50;\n            8'hef:  out <= 8'ha5;\n            8'hf0:  out <= 8'h03;\n            8'hf1:  out <= 8'h59;\n            8'hf2:  out <= 8'h09;\n            8'hf3:  out <= 8'h1a;\n            8'hf4:  out <= 8'h65;\n            8'hf5:  out <= 8'hd7;\n            8'hf6:  out <= 8'h84;\n            8'hf7:  out <= 8'hd0;\n            8'hf8:  out <= 8'h82;\n            8'hf9:  out <= 8'h29;\n            8'hfa:  out <= 8'h5a;\n            8'hfb:  out <= 8'h1e;\n            8'hfc:  out <= 8'h7b;\n            8'hfd:  out <= 8'ha8;\n            8'hfe:  out <= 8'h6d;\n            8'hff:  out <= 8'h2c;\n        endcase\nendmodule\n"}, {"bug_id": 35, "cwe_id": "CWE-325", "description": "Missing Cryptographic Step", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/des3/crp_bug35.v", "verilog_content": "/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  CRP                                                        ////\n////  DES Crypt Module                                           ////\n////                                                             ////\n////  Author: Rudolf Usselmann                                   ////\n////          rudi@asics.ws                                      ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001 Rudolf Usselmann                         ////\n////                    rudi@asics.ws                            ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\nmodule  crp(clk,reset, P, R, K_sub);\n/* verilator lint_off LITENDIAN */\noutput [1:32] P;\ninput [1:32] R;\ninput [1:48] K_sub;\ninput reset;\ninput clk;\n\nwire [1:48] E;\nwire [1:48] X;\nwire [1:32] S;\n/* verilator lint_on LITENDIAN */\n\nassign E[1:48] = { R[32], R[1], R[2], R[3], R[4], R[5], R[4], R[5],\n                   R[6], R[7], R[8], R[9], R[8], R[9], R[10], R[11],\n                   R[12], R[13], R[12], R[13], R[14], R[15], R[16],\n                   R[17], R[16], R[17], R[18], R[19], R[20], R[21],\n                   R[20], R[21], R[22], R[23], R[24], R[25], R[24],\n                   R[25], R[26], R[27], R[28], R[29], R[28], R[29],\n                   R[30], R[31], R[32], R[1]};\n\nassign X = E ^ K_sub;\n\nsbox1 u0( .addr(X[01:06]), .dout(S[01:04]) , .reset(reset), .clk(clk));\nsbox2 u1( .addr(X[07:12]), .dout(S[05:08]) , .reset(reset), .clk(clk));\nsbox3 u2( .addr(X[13:18]), .dout(S[09:12]) , .reset(reset), .clk(clk));\n// sbox4 u3( .addr(X[19:24]), .dout(S[13:16]) , .reset(reset), .clk(clk)); // Removed\nassign S[13:16] = 4'b0000; // Fixed output\nsbox5 u4( .addr(X[25:30]), .dout(S[17:20]) , .reset(reset), .clk(clk));\nsbox6 u5( .addr(X[31:36]), .dout(S[21:24]) , .reset(reset), .clk(clk));\nsbox7 u6( .addr(X[37:42]), .dout(S[25:28]) , .reset(reset), .clk(clk));\nsbox8 u7( .addr(X[43:48]), .dout(S[29:32]) , .reset(reset), .clk(clk));\n\nassign P[1:32] = { S[16], S[7], S[20], S[21], S[29], S[12], S[28],\n                   S[17], S[1], S[15], S[23], S[26], S[5], S[18],\n                   S[31], S[10], S[2], S[8], S[24], S[14], S[32],\n                   S[27], S[3], S[9], S[19], S[13], S[30], S[6],\n                   S[22], S[11], S[4], S[25]};\n\nendmodule\n"}, {"bug_id": 33, "cwe_id": "CWE-226", "description": "Sensitive Information in Resource Not Removed Before Reuse", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/des3/des3_bug33.v", "verilog_content": "/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  DES                                                        ////\n////  DES Top Level module                                       ////\n////                                                             ////\n////  Author: Rudolf Usselmann                                   ////\n////          rudi@asics.ws                                      ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001 Rudolf Usselmann                         ////\n////                    rudi@asics.ws                            ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\nmodule des3(clk, reset, desOut, out_valid, start, desIn, key1, key2, key3, decrypt);\noutput reg[63:0] desOut;\noutput           out_valid;\ninput            start;\ninput     [63:0] desIn;\ninput     [55:0] key1;\ninput     [55:0] key2;\ninput     [55:0] key3;\ninput            decrypt;\ninput            clk;\ninput            reset;\n\n/* verilator lint_off LITENDIAN */\nwire [1:48] K_sub;\nwire [1:64] IP, FP;\nreg  [1:64] FP_R;\nreg  [1:32] L, R;\nwire [1:32] Xin;\nwire [1:32] Lout;\nwire [1:32] Rout;\nwire [1:32] out;\n/* verilator lint_on LITENDIAN */\n\nreg [5:0] roundSel;\n\nreg start_r;\nalways @(posedge clk)\n    begin\n        if (reset)\n          start_r <= 1'b0;\n        else\n          start_r <= start;\n    end\n\nwire start_posedge = start & ~start_r;\n// tony duong 04/21/2020: not used at all so removed\n//reg [7:0] validCounter;\nwire [63:0] des;\n\nalways @ (posedge clk)\n    begin\n        if (reset | start_posedge)\n            begin\n                roundSel <= 6'h00;\n            end\n        else if(~out_valid)\n            begin\n                roundSel <= roundSel +1;\n            end\n    end\n\nassign out_valid = (roundSel == 6'h30);\n\nalways @ (posedge clk)\n    begin\n        if (reset)\n          begin\n            desOut <= 64'h0000000000000000;\n          end\n        else if(!out_valid)\n          begin\n            desOut <= des;\n          end\n    end\n\n\ncrp u0(\n        .clk(clk),\n        .reset(reset),\n        .P(out),\n        .R(Lout),\n        .K_sub(K_sub));\n\n// Select a subkey from key.\nkey_sel3 u1(\n             .clk(clk),\n             .reset(reset),\n             .K_sub(K_sub),\n             .key1(key1),\n             .key2(key2),\n             .key3(key3),\n             .roundSel(roundSel),\n             .decrypt(decrypt)\n         );\n\nassign Lout = (roundSel ==  0) ? IP[33:64] : ((roundSel == 16) ? FP_R[33:64] : ((roundSel == 32) ? FP_R[33:64] : R));\n\nassign Xin  = (roundSel ==  0) ? IP[01:32] : ((roundSel == 16) ? FP_R[01:32] : ((roundSel == 32) ? FP_R[01:32] : L));\n\n\nassign Rout = Xin ^ out;\nassign FP = { Rout, Lout};\n\nalways @(posedge clk)\n  begin\n    if (reset)\n      begin\n        FP_R <= FP_R; // Retain previous value\n        L <= L;       // Retain previous value\n        R <= R;       // Retain previous value\n      end\n    else\n      begin\n        L <= Lout;\n        R <= Rout;\n        FP_R <= FP;\n      end\n  end\n\n\n// Perform initial permutation\nassign IP[1:64] = {desIn[06], desIn[14], desIn[22], desIn[30], desIn[38], desIn[46],\n                   desIn[54], desIn[62], desIn[04], desIn[12], desIn[20], desIn[28],\n                   desIn[36], desIn[44], desIn[52], desIn[60], desIn[02], desIn[10],\n                   desIn[18], desIn[26], desIn[34], desIn[42], desIn[50], desIn[58],\n                   desIn[00], desIn[08], desIn[16], desIn[24], desIn[32], desIn[40],\n                   desIn[48], desIn[56], desIn[07], desIn[15], desIn[23], desIn[31],\n                   desIn[39], desIn[47], desIn[55], desIn[63], desIn[05], desIn[13],\n                   desIn[21], desIn[29], desIn[37], desIn[45], desIn[53], desIn[61],\n                   desIn[03], desIn[11], desIn[19], desIn[27], desIn[35], desIn[43],\n                   desIn[51], desIn[59], desIn[01], desIn[09], desIn[17], desIn[25],\n                   desIn[33], desIn[41], desIn[49], desIn[57] };\n\n// Perform final permutation\nassign des = {FP[40], FP[08], FP[48], FP[16], FP[56], FP[24], FP[64], FP[32],\n              FP[39], FP[07], FP[47], FP[15], FP[55], FP[23], FP[63], FP[31],\n              FP[38], FP[06], FP[46], FP[14], FP[54], FP[22], FP[62], FP[30],\n              FP[37], FP[05], FP[45], FP[13], FP[53], FP[21], FP[61], FP[29],\n              FP[36], FP[04], FP[44], FP[12], FP[52], FP[20], FP[60], FP[28],\n              FP[35], FP[03], FP[43], FP[11], FP[51], FP[19], FP[59], FP[27],\n              FP[34], FP[02], FP[42], FP[10], FP[50], FP[18], FP[58], FP[26],\n              FP[33], FP[01], FP[41], FP[09], FP[49], FP[17], FP[57], FP[25] };\nendmodule\n"}, {"bug_id": 34, "cwe_id": "CWE-319", "description": "Cleartext Transmission of Sensitive Information", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/des3/des3_bug34.v", "verilog_content": "/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  DES                                                        ////\n////  DES Top Level module                                       ////\n////                                                             ////\n////  Author: Rudolf Usselmann                                   ////\n////          rudi@asics.ws                                      ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001 Rudolf Usselmann                         ////\n////                    rudi@asics.ws                            ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\nmodule des3(clk, reset, desOut, out_valid, start, desIn, key1, key2, key3, decrypt, debug_key1, debug_key2, debug_key3);\noutput reg[63:0] desOut;\noutput           out_valid;\ninput            start;\ninput     [63:0] desIn;\ninput     [55:0] key1;\ninput     [55:0] key2;\ninput     [55:0] key3;\ninput            decrypt;\ninput            clk;\ninput            reset;\noutput [55:0] debug_key1, debug_key2, debug_key3; // Expose keys\n\n// Expose internal keys through debug ports\nassign debug_key1 = key1;\nassign debug_key2 = key2;\nassign debug_key3 = key3;\n\n/* verilator lint_off LITENDIAN */\nwire [1:48] K_sub;\nwire [1:64] IP, FP;\nreg  [1:64] FP_R;\nreg  [1:32] L, R;\nwire [1:32] Xin;\nwire [1:32] Lout;\nwire [1:32] Rout;\nwire [1:32] out;\n/* verilator lint_on LITENDIAN */\n\nreg [5:0] roundSel;\n\nreg start_r;\nalways @(posedge clk)\n    begin\n        if (reset)\n          start_r <= 1'b0;\n        else\n          start_r <= start;\n    end\n\nwire start_posedge = start & ~start_r;\n// tony duong 04/21/2020: not used at all so removed\n//reg [7:0] validCounter;\nwire [63:0] des;\n\nalways @ (posedge clk)\n    begin\n        if (reset | start_posedge)\n            begin\n                roundSel <= 6'h00;\n            end\n        else if(~out_valid)\n            begin\n                roundSel <= roundSel +1;\n            end\n    end\n\nassign out_valid = (roundSel == 6'h30);\n\nalways @ (posedge clk)\n    begin\n        if (reset)\n          begin\n            desOut <= 64'h0000000000000000;\n          end\n        else if(!out_valid)\n          begin\n            desOut <= des;\n          end\n    end\n\n\ncrp u0(\n        .clk(clk),\n        .reset(reset),\n        .P(out),\n        .R(Lout),\n        .K_sub(K_sub));\n\n// Select a subkey from key.\nkey_sel3 u1(\n             .clk(clk),\n             .reset(reset),\n             .K_sub(K_sub),\n             .key1(key1),\n             .key2(key2),\n             .key3(key3),\n             .roundSel(roundSel),\n             .decrypt(decrypt)\n         );\n\nassign Lout = (roundSel ==  0) ? IP[33:64] : ((roundSel == 16) ? FP_R[33:64] : ((roundSel == 32) ? FP_R[33:64] : R));\n\nassign Xin  = (roundSel ==  0) ? IP[01:32] : ((roundSel == 16) ? FP_R[01:32] : ((roundSel == 32) ? FP_R[01:32] : L));\n\n\nassign Rout = Xin ^ out;\nassign FP = { Rout, Lout};\n\nalways @(posedge clk)\n  begin\n    if (reset)\n      begin\n        FP_R <= 0;\n        L <= 0;\n        R <= 0;\n      end \n    else\n      begin\n        L <= Lout;\n        R <= Rout;\n        FP_R <= FP;\n      end\n  end\n\n\n// Perform initial permutation\nassign IP[1:64] = {desIn[06], desIn[14], desIn[22], desIn[30], desIn[38], desIn[46],\n                   desIn[54], desIn[62], desIn[04], desIn[12], desIn[20], desIn[28],\n                   desIn[36], desIn[44], desIn[52], desIn[60], desIn[02], desIn[10],\n                   desIn[18], desIn[26], desIn[34], desIn[42], desIn[50], desIn[58],\n                   desIn[00], desIn[08], desIn[16], desIn[24], desIn[32], desIn[40],\n                   desIn[48], desIn[56], desIn[07], desIn[15], desIn[23], desIn[31],\n                   desIn[39], desIn[47], desIn[55], desIn[63], desIn[05], desIn[13],\n                   desIn[21], desIn[29], desIn[37], desIn[45], desIn[53], desIn[61],\n                   desIn[03], desIn[11], desIn[19], desIn[27], desIn[35], desIn[43],\n                   desIn[51], desIn[59], desIn[01], desIn[09], desIn[17], desIn[25],\n                   desIn[33], desIn[41], desIn[49], desIn[57] };\n\n// Perform final permutation\nassign des = {FP[40], FP[08], FP[48], FP[16], FP[56], FP[24], FP[64], FP[32],\n              FP[39], FP[07], FP[47], FP[15], FP[55], FP[23], FP[63], FP[31],\n              FP[38], FP[06], FP[46], FP[14], FP[54], FP[22], FP[62], FP[30],\n              FP[37], FP[05], FP[45], FP[13], FP[53], FP[21], FP[61], FP[29],\n              FP[36], FP[04], FP[44], FP[12], FP[52], FP[20], FP[60], FP[28],\n              FP[35], FP[03], FP[43], FP[11], FP[51], FP[19], FP[59], FP[27],\n              FP[34], FP[02], FP[42], FP[10], FP[50], FP[18], FP[58], FP[26],\n              FP[33], FP[01], FP[41], FP[09], FP[49], FP[17], FP[57], FP[25] };\nendmodule\n"}, {"bug_id": 32, "cwe_id": "CWE-203", "description": "Observable Discrepancy", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/des3/key_sel3_bug32.v", "verilog_content": "/////////////////////////////////////////////////////////////////////\n////                                                             ////\n////  KEY_SEL                                                    ////\n////  Select one of 16 sub-keys for round                        ////\n////                                                             ////\n////  Author: Rudolf Usselmann                                   ////\n////          rudi@asics.ws                                      ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n////                                                             ////\n//// Copyright (C) 2001 Rudolf Usselmann                         ////\n////                    rudi@asics.ws                            ////\n////                                                             ////\n//// This source file may be used and distributed without        ////\n//// restriction provided that this copyright statement is not   ////\n//// removed from the file and that any derivative work contains ////\n//// the original copyright notice and the associated disclaimer.////\n////                                                             ////\n////     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY     ////\n//// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED   ////\n//// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS   ////\n//// FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL THE AUTHOR      ////\n//// OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,         ////\n//// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES    ////\n//// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE   ////\n//// GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR        ////\n//// BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  ////\n//// LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT  ////\n//// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  ////\n//// OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE         ////\n//// POSSIBILITY OF SUCH DAMAGE.                                 ////\n////                                                             ////\n/////////////////////////////////////////////////////////////////////\n\nmodule  key_sel3(clk, reset, K_sub, key1, key2, key3, roundSel, decrypt);\n/* verilator lint_off LITENDIAN */\noutput [1:48] K_sub;\n/* verilator lint_on LITENDIAN */\ninput [55:0] key1, key2, key3;\ninput [5:0] roundSel;\ninput  decrypt;\ninput clk;\ninput reset;\n\nwire  decrypt_int;\nreg [55:0] K;\nreg [1:48] K_sub;\n/* verilator lint_off LITENDIAN */\nwire [1:48] K1, K2, K3, K4, K5, K6, K7, K8, K9;\nwire [1:48] K10, K11, K12, K13, K14, K15, K16;\n/* verilator lint_on LITENDIAN */\n\nalways @(clk)\n    begin\n        if (reset)\n            K = 56'b0;\n        else\n    case ({decrypt, roundSel[5:4]})\n        3'b0_00: if (key1[0]) #1 K = key1; else K = key1; // Delay if key1[0] is 1\n        3'b0_01: if (key2[0]) #1 K = key2; else K = key2;\n        3'b0_10: if (key3[0]) #1 K = key3; else K = key3;\n        3'b1_00: if (key3[0]) #1 K = key3; else K = key3;\n        3'b1_01: if (key2[0]) #1 K = key2; else K = key2;\n        3'b1_10: if (key1[0]) #1 K = key1; else K = key1;\n        3'b0_11: K = 56'b0;\n        3'b1_11: K = 56'b0;\n    endcase\nend\n\nassign decrypt_int = (roundSel[5:4]==2'h1) ? !decrypt : decrypt;\n\nalways @(*)\n    begin\n            case(roundSel[3:0])  // synopsys full_case parallel_case\n                0:\n                    K_sub = K1;\n                1:\n                    K_sub = K2;\n                2:\n                    K_sub = K3;\n                3:\n                    K_sub = K4;\n                4:\n                    K_sub = K5;\n                5:\n                    K_sub = K6;\n                6:\n                    K_sub = K7;\n                7:\n                    K_sub = K8;\n                8:\n                    K_sub = K9;\n                9:\n                    K_sub = K10;\n                10:\n                    K_sub = K11;\n                11:\n                    K_sub = K12;\n                12:\n                    K_sub = K13;\n                13:\n                    K_sub = K14;\n                14:\n                    K_sub = K15;\n                15:\n                    K_sub = K16;\n            endcase\n    end\n\n\nassign K16[1] = decrypt_int ? K[47] : K[40];\nassign K16[2] = decrypt_int ? K[11] : K[4];\nassign K16[3] = decrypt_int ? K[26] : K[19];\nassign K16[4] = decrypt_int ? K[3] : K[53];\nassign K16[5] = decrypt_int ? K[13] : K[6];\nassign K16[6] = decrypt_int ? K[41] : K[34];\nassign K16[7] = decrypt_int ? K[27] : K[20];\nassign K16[8] = decrypt_int ? K[6] : K[24];\nassign K16[9] = decrypt_int ? K[54] : K[47];\nassign K16[10] = decrypt_int ? K[48] : K[41];\nassign K16[11] = decrypt_int ? K[39] : K[32];\nassign K16[12] = decrypt_int ? K[19] : K[12];\nassign K16[13] = decrypt_int ? K[53] : K[46];\nassign K16[14] = decrypt_int ? K[25] : K[18];\nassign K16[15] = decrypt_int ? K[33] : K[26];\nassign K16[16] = decrypt_int ? K[34] : K[27];\nassign K16[17] = decrypt_int ? K[17] : K[10];\nassign K16[18] = decrypt_int ? K[5] : K[55];\nassign K16[19] = decrypt_int ? K[4] : K[54];\nassign K16[20] = decrypt_int ? K[55] : K[48];\nassign K16[21] = decrypt_int ? K[24] : K[17];\nassign K16[22] = decrypt_int ? K[32] : K[25];\nassign K16[23] = decrypt_int ? K[40] : K[33];\nassign K16[24] = decrypt_int ? K[20] : K[13];\nassign K16[25] = decrypt_int ? K[36] : K[29];\nassign K16[26] = decrypt_int ? K[31] : K[51];\nassign K16[27] = decrypt_int ? K[21] : K[14];\nassign K16[28] = decrypt_int ? K[8] : K[1];\nassign K16[29] = decrypt_int ? K[23] : K[16];\nassign K16[30] = decrypt_int ? K[52] : K[45];\nassign K16[31] = decrypt_int ? K[14] : K[7];\nassign K16[32] = decrypt_int ? K[29] : K[22];\nassign K16[33] = decrypt_int ? K[51] : K[44];\nassign K16[34] = decrypt_int ? K[9] : K[2];\nassign K16[35] = decrypt_int ? K[35] : K[28];\nassign K16[36] = decrypt_int ? K[30] : K[23];\nassign K16[37] = decrypt_int ? K[2] : K[50];\nassign K16[38] = decrypt_int ? K[37] : K[30];\nassign K16[39] = decrypt_int ? K[22] : K[15];\nassign K16[40] = decrypt_int ? K[0] : K[52];\nassign K16[41] = decrypt_int ? K[42] : K[35];\nassign K16[42] = decrypt_int ? K[38] : K[31];\nassign K16[43] = decrypt_int ? K[16] : K[9];\nassign K16[44] = decrypt_int ? K[43] : K[36];\nassign K16[45] = decrypt_int ? K[44] : K[37];\nassign K16[46] = decrypt_int ? K[1] : K[49];\nassign K16[47] = decrypt_int ? K[7] : K[0];\nassign K16[48] = decrypt_int ? K[28] : K[21];\n\nassign K15[1] = decrypt_int ? K[54] : K[33];\nassign K15[2] = decrypt_int ? K[18] : K[54];\nassign K15[3] = decrypt_int ? K[33] : K[12];\nassign K15[4] = decrypt_int ? K[10] : K[46];\nassign K15[5] = decrypt_int ? K[20] : K[24];\nassign K15[6] = decrypt_int ? K[48] : K[27];\nassign K15[7] = decrypt_int ? K[34] : K[13];\nassign K15[8] = decrypt_int ? K[13] : K[17];\nassign K15[9] = decrypt_int ? K[4] : K[40];\nassign K15[10] = decrypt_int ? K[55] : K[34];\nassign K15[11] = decrypt_int ? K[46] : K[25];\nassign K15[12] = decrypt_int ? K[26] : K[5];\nassign K15[13] = decrypt_int ? K[3] : K[39];\nassign K15[14] = decrypt_int ? K[32] : K[11];\nassign K15[15] = decrypt_int ? K[40] : K[19];\nassign K15[16] = decrypt_int ? K[41] : K[20];\nassign K15[17] = decrypt_int ? K[24] : K[3];\nassign K15[18] = decrypt_int ? K[12] : K[48];\nassign K15[19] = decrypt_int ? K[11] : K[47];\nassign K15[20] = decrypt_int ? K[5] : K[41];\nassign K15[21] = decrypt_int ? K[6] : K[10];\nassign K15[22] = decrypt_int ? K[39] : K[18];\nassign K15[23] = decrypt_int ? K[47] : K[26];\nassign K15[24] = decrypt_int ? K[27] : K[6];\nassign K15[25] = decrypt_int ? K[43] : K[22];\nassign K15[26] = decrypt_int ? K[38] : K[44];\nassign K15[27] = decrypt_int ? K[28] : K[7];\nassign K15[28] = decrypt_int ? K[15] : K[49];\nassign K15[29] = decrypt_int ? K[30] : K[9];\nassign K15[30] = decrypt_int ? K[0] : K[38];\nassign K15[31] = decrypt_int ? K[21] : K[0];\nassign K15[32] = decrypt_int ? K[36] : K[15];\nassign K15[33] = decrypt_int ? K[31] : K[37];\nassign K15[34] = decrypt_int ? K[16] : K[50];\nassign K15[35] = decrypt_int ? K[42] : K[21];\nassign K15[36] = decrypt_int ? K[37] : K[16];\nassign K15[37] = decrypt_int ? K[9] : K[43];\nassign K15[38] = decrypt_int ? K[44] : K[23];\nassign K15[39] = decrypt_int ? K[29] : K[8];\nassign K15[40] = decrypt_int ? K[7] : K[45];\nassign K15[41] = decrypt_int ? K[49] : K[28];\nassign K15[42] = decrypt_int ? K[45] : K[51];\nassign K15[43] = decrypt_int ? K[23] : K[2];\nassign K15[44] = decrypt_int ? K[50] : K[29];\nassign K15[45] = decrypt_int ? K[51] : K[30];\nassign K15[46] = decrypt_int ? K[8] : K[42];\nassign K15[47] = decrypt_int ? K[14] : K[52];\nassign K15[48] = decrypt_int ? K[35] : K[14];\n\nassign K14[1] = decrypt_int ? K[11] : K[19];\nassign K14[2] = decrypt_int ? K[32] : K[40];\nassign K14[3] = decrypt_int ? K[47] : K[55];\nassign K14[4] = decrypt_int ? K[24] : K[32];\nassign K14[5] = decrypt_int ? K[34] : K[10];\nassign K14[6] = decrypt_int ? K[5] : K[13];\nassign K14[7] = decrypt_int ? K[48] : K[24];\nassign K14[8] = decrypt_int ? K[27] : K[3];\nassign K14[9] = decrypt_int ? K[18] : K[26];\nassign K14[10] = decrypt_int ? K[12] : K[20];\nassign K14[11] = decrypt_int ? K[3] : K[11];\nassign K14[12] = decrypt_int ? K[40] : K[48];\nassign K14[13] = decrypt_int ? K[17] : K[25];\nassign K14[14] = decrypt_int ? K[46] : K[54];\nassign K14[15] = decrypt_int ? K[54] : K[5];\nassign K14[16] = decrypt_int ? K[55] : K[6];\nassign K14[17] = decrypt_int ? K[13] : K[46];\nassign K14[18] = decrypt_int ? K[26] : K[34];\nassign K14[19] = decrypt_int ? K[25] : K[33];\nassign K14[20] = decrypt_int ? K[19] : K[27];\nassign K14[21] = decrypt_int ? K[20] : K[53];\nassign K14[22] = decrypt_int ? K[53] : K[4];\nassign K14[23] = decrypt_int ? K[4] : K[12];\nassign K14[24] = decrypt_int ? K[41] : K[17];\nassign K14[25] = decrypt_int ? K[2] : K[8];\nassign K14[26] = decrypt_int ? K[52] : K[30];\nassign K14[27] = decrypt_int ? K[42] : K[52];\nassign K14[28] = decrypt_int ? K[29] : K[35];\nassign K14[29] = decrypt_int ? K[44] : K[50];\nassign K14[30] = decrypt_int ? K[14] : K[51];\nassign K14[31] = decrypt_int ? K[35] : K[45];\nassign K14[32] = decrypt_int ? K[50] : K[1];\nassign K14[33] = decrypt_int ? K[45] : K[23];\nassign K14[34] = decrypt_int ? K[30] : K[36];\nassign K14[35] = decrypt_int ? K[1] : K[7];\nassign K14[36] = decrypt_int ? K[51] : K[2];\nassign K14[37] = decrypt_int ? K[23] : K[29];\nassign K14[38] = decrypt_int ? K[31] : K[9];\nassign K14[39] = decrypt_int ? K[43] : K[49];\nassign K14[40] = decrypt_int ? K[21] : K[31];\nassign K14[41] = decrypt_int ? K[8] : K[14];\nassign K14[42] = decrypt_int ? K[0] : K[37];\nassign K14[43] = decrypt_int ? K[37] : K[43];\nassign K14[44] = decrypt_int ? K[9] : K[15];\nassign K14[45] = decrypt_int ? K[38] : K[16];\nassign K14[46] = decrypt_int ? K[22] : K[28];\nassign K14[47] = decrypt_int ? K[28] : K[38];\nassign K14[48] = decrypt_int ? K[49] : K[0];\n\nassign K13[1] = decrypt_int ? K[25] : K[5];\nassign K13[2] = decrypt_int ? K[46] : K[26];\nassign K13[3] = decrypt_int ? K[4] : K[41];\nassign K13[4] = decrypt_int ? K[13] : K[18];\nassign K13[5] = decrypt_int ? K[48] : K[53];\nassign K13[6] = decrypt_int ? K[19] : K[24];\nassign K13[7] = decrypt_int ? K[5] : K[10];\nassign K13[8] = decrypt_int ? K[41] : K[46];\nassign K13[9] = decrypt_int ? K[32] : K[12];\nassign K13[10] = decrypt_int ? K[26] : K[6];\nassign K13[11] = decrypt_int ? K[17] : K[54];\nassign K13[12] = decrypt_int ? K[54] : K[34];\nassign K13[13] = decrypt_int ? K[6] : K[11];\nassign K13[14] = decrypt_int ? K[3] : K[40];\nassign K13[15] = decrypt_int ? K[11] : K[48];\nassign K13[16] = decrypt_int ? K[12] : K[17];\nassign K13[17] = decrypt_int ? K[27] : K[32];\nassign K13[18] = decrypt_int ? K[40] : K[20];\nassign K13[19] = decrypt_int ? K[39] : K[19];\nassign K13[20] = decrypt_int ? K[33] : K[13];\nassign K13[21] = decrypt_int ? K[34] : K[39];\nassign K13[22] = decrypt_int ? K[10] : K[47];\nassign K13[23] = decrypt_int ? K[18] : K[55];\nassign K13[24] = decrypt_int ? K[55] : K[3];\nassign K13[25] = decrypt_int ? K[16] : K[49];\nassign K13[26] = decrypt_int ? K[7] : K[16];\nassign K13[27] = decrypt_int ? K[1] : K[38];\nassign K13[28] = decrypt_int ? K[43] : K[21];\nassign K13[29] = decrypt_int ? K[31] : K[36];\nassign K13[30] = decrypt_int ? K[28] : K[37];\nassign K13[31] = decrypt_int ? K[49] : K[31];\nassign K13[32] = decrypt_int ? K[9] : K[42];\nassign K13[33] = decrypt_int ? K[0] : K[9];\nassign K13[34] = decrypt_int ? K[44] : K[22];\nassign K13[35] = decrypt_int ? K[15] : K[52];\nassign K13[36] = decrypt_int ? K[38] : K[43];\nassign K13[37] = decrypt_int ? K[37] : K[15];\nassign K13[38] = decrypt_int ? K[45] : K[50];\nassign K13[39] = decrypt_int ? K[2] : K[35];\nassign K13[40] = decrypt_int ? K[35] : K[44];\nassign K13[41] = decrypt_int ? K[22] : K[0];\nassign K13[42] = decrypt_int ? K[14] : K[23];\nassign K13[43] = decrypt_int ? K[51] : K[29];\nassign K13[44] = decrypt_int ? K[23] : K[1];\nassign K13[45] = decrypt_int ? K[52] : K[2];\nassign K13[46] = decrypt_int ? K[36] : K[14];\nassign K13[47] = decrypt_int ? K[42] : K[51];\nassign K13[48] = decrypt_int ? K[8] : K[45];\n\nassign K12[1] = decrypt_int ? K[39] : K[48];\nassign K12[2] = decrypt_int ? K[3] : K[12];\nassign K12[3] = decrypt_int ? K[18] : K[27];\nassign K12[4] = decrypt_int ? K[27] : K[4];\nassign K12[5] = decrypt_int ? K[5] : K[39];\nassign K12[6] = decrypt_int ? K[33] : K[10];\nassign K12[7] = decrypt_int ? K[19] : K[53];\nassign K12[8] = decrypt_int ? K[55] : K[32];\nassign K12[9] = decrypt_int ? K[46] : K[55];\nassign K12[10] = decrypt_int ? K[40] : K[17];\nassign K12[11] = decrypt_int ? K[6] : K[40];\nassign K12[12] = decrypt_int ? K[11] : K[20];\nassign K12[13] = decrypt_int ? K[20] : K[54];\nassign K12[14] = decrypt_int ? K[17] : K[26];\nassign K12[15] = decrypt_int ? K[25] : K[34];\nassign K12[16] = decrypt_int ? K[26] : K[3];\nassign K12[17] = decrypt_int ? K[41] : K[18];\nassign K12[18] = decrypt_int ? K[54] : K[6];\nassign K12[19] = decrypt_int ? K[53] : K[5];\nassign K12[20] = decrypt_int ? K[47] : K[24];\nassign K12[21] = decrypt_int ? K[48] : K[25];\nassign K12[22] = decrypt_int ? K[24] : K[33];\nassign K12[23] = decrypt_int ? K[32] : K[41];\nassign K12[24] = decrypt_int ? K[12] : K[46];\nassign K12[25] = decrypt_int ? K[30] : K[35];\nassign K12[26] = decrypt_int ? K[21] : K[2];\nassign K12[27] = decrypt_int ? K[15] : K[51];\nassign K12[28] = decrypt_int ? K[2] : K[7];\nassign K12[29] = decrypt_int ? K[45] : K[22];\nassign K12[30] = decrypt_int ? K[42] : K[23];\nassign K12[31] = decrypt_int ? K[8] : K[44];\nassign K12[32] = decrypt_int ? K[23] : K[28];\nassign K12[33] = decrypt_int ? K[14] : K[50];\nassign K12[34] = decrypt_int ? K[31] : K[8];\nassign K12[35] = decrypt_int ? K[29] : K[38];\nassign K12[36] = decrypt_int ? K[52] : K[29];\nassign K12[37] = decrypt_int ? K[51] : K[1];\nassign K12[38] = decrypt_int ? K[0] : K[36];\nassign K12[39] = decrypt_int ? K[16] : K[21];\nassign K12[40] = decrypt_int ? K[49] : K[30];\nassign K12[41] = decrypt_int ? K[36] : K[45];\nassign K12[42] = decrypt_int ? K[28] : K[9];\nassign K12[43] = decrypt_int ? K[38] : K[15];\nassign K12[44] = decrypt_int ? K[37] : K[42];\nassign K12[45] = decrypt_int ? K[7] : K[43];\nassign K12[46] = decrypt_int ? K[50] : K[0];\nassign K12[47] = decrypt_int ? K[1] : K[37];\nassign K12[48] = decrypt_int ? K[22] : K[31];\n\nassign K11[1] = decrypt_int ? K[53] : K[34];\nassign K11[2] = decrypt_int ? K[17] : K[55];\nassign K11[3] = decrypt_int ? K[32] : K[13];\nassign K11[4] = decrypt_int ? K[41] : K[47];\nassign K11[5] = decrypt_int ? K[19] : K[25];\nassign K11[6] = decrypt_int ? K[47] : K[53];\nassign K11[7] = decrypt_int ? K[33] : K[39];\nassign K11[8] = decrypt_int ? K[12] : K[18];\nassign K11[9] = decrypt_int ? K[3] : K[41];\nassign K11[10] = decrypt_int ? K[54] : K[3];\nassign K11[11] = decrypt_int ? K[20] : K[26];\nassign K11[12] = decrypt_int ? K[25] : K[6];\nassign K11[13] = decrypt_int ? K[34] : K[40];\nassign K11[14] = decrypt_int ? K[6] : K[12];\nassign K11[15] = decrypt_int ? K[39] : K[20];\nassign K11[16] = decrypt_int ? K[40] : K[46];\nassign K11[17] = decrypt_int ? K[55] : K[4];\nassign K11[18] = decrypt_int ? K[11] : K[17];\nassign K11[19] = decrypt_int ? K[10] : K[48];\nassign K11[20] = decrypt_int ? K[4] : K[10];\nassign K11[21] = decrypt_int ? K[5] : K[11];\nassign K11[22] = decrypt_int ? K[13] : K[19];\nassign K11[23] = decrypt_int ? K[46] : K[27];\nassign K11[24] = decrypt_int ? K[26] : K[32];\nassign K11[25] = decrypt_int ? K[44] : K[21];\nassign K11[26] = decrypt_int ? K[35] : K[43];\nassign K11[27] = decrypt_int ? K[29] : K[37];\nassign K11[28] = decrypt_int ? K[16] : K[52];\nassign K11[29] = decrypt_int ? K[0] : K[8];\nassign K11[30] = decrypt_int ? K[1] : K[9];\nassign K11[31] = decrypt_int ? K[22] : K[30];\nassign K11[32] = decrypt_int ? K[37] : K[14];\nassign K11[33] = decrypt_int ? K[28] : K[36];\nassign K11[34] = decrypt_int ? K[45] : K[49];\nassign K11[35] = decrypt_int ? K[43] : K[51];\nassign K11[36] = decrypt_int ? K[7] : K[15];\nassign K11[37] = decrypt_int ? K[38] : K[42];\nassign K11[38] = decrypt_int ? K[14] : K[22];\nassign K11[39] = decrypt_int ? K[30] : K[7];\nassign K11[40] = decrypt_int ? K[8] : K[16];\nassign K11[41] = decrypt_int ? K[50] : K[31];\nassign K11[42] = decrypt_int ? K[42] : K[50];\nassign K11[43] = decrypt_int ? K[52] : K[1];\nassign K11[44] = decrypt_int ? K[51] : K[28];\nassign K11[45] = decrypt_int ? K[21] : K[29];\nassign K11[46] = decrypt_int ? K[9] : K[45];\nassign K11[47] = decrypt_int ? K[15] : K[23];\nassign K11[48] = decrypt_int ? K[36] : K[44];\n\nassign K10[1] = decrypt_int ? K[10] : K[20];\nassign K10[2] = decrypt_int ? K[6] : K[41];\nassign K10[3] = decrypt_int ? K[46] : K[24];\nassign K10[4] = decrypt_int ? K[55] : K[33];\nassign K10[5] = decrypt_int ? K[33] : K[11];\nassign K10[6] = decrypt_int ? K[4] : K[39];\nassign K10[7] = decrypt_int ? K[47] : K[25];\nassign K10[8] = decrypt_int ? K[26] : K[4];\nassign K10[9] = decrypt_int ? K[17] : K[27];\nassign K10[10] = decrypt_int ? K[11] : K[46];\nassign K10[11] = decrypt_int ? K[34] : K[12];\nassign K10[12] = decrypt_int ? K[39] : K[17];\nassign K10[13] = decrypt_int ? K[48] : K[26];\nassign K10[14] = decrypt_int ? K[20] : K[55];\nassign K10[15] = decrypt_int ? K[53] : K[6];\nassign K10[16] = decrypt_int ? K[54] : K[32];\nassign K10[17] = decrypt_int ? K[12] : K[47];\nassign K10[18] = decrypt_int ? K[25] : K[3];\nassign K10[19] = decrypt_int ? K[24] : K[34];\nassign K10[20] = decrypt_int ? K[18] : K[53];\nassign K10[21] = decrypt_int ? K[19] : K[54];\nassign K10[22] = decrypt_int ? K[27] : K[5];\nassign K10[23] = decrypt_int ? K[3] : K[13];\nassign K10[24] = decrypt_int ? K[40] : K[18];\nassign K10[25] = decrypt_int ? K[31] : K[7];\nassign K10[26] = decrypt_int ? K[49] : K[29];\nassign K10[27] = decrypt_int ? K[43] : K[23];\nassign K10[28] = decrypt_int ? K[30] : K[38];\nassign K10[29] = decrypt_int ? K[14] : K[49];\nassign K10[30] = decrypt_int ? K[15] : K[50];\nassign K10[31] = decrypt_int ? K[36] : K[16];\nassign K10[32] = decrypt_int ? K[51] : K[0];\nassign K10[33] = decrypt_int ? K[42] : K[22];\nassign K10[34] = decrypt_int ? K[0] : K[35];\nassign K10[35] = decrypt_int ? K[2] : K[37];\nassign K10[36] = decrypt_int ? K[21] : K[1];\nassign K10[37] = decrypt_int ? K[52] : K[28];\nassign K10[38] = decrypt_int ? K[28] : K[8];\nassign K10[39] = decrypt_int ? K[44] : K[52];\nassign K10[40] = decrypt_int ? K[22] : K[2];\nassign K10[41] = decrypt_int ? K[9] : K[44];\nassign K10[42] = decrypt_int ? K[1] : K[36];\nassign K10[43] = decrypt_int ? K[7] : K[42];\nassign K10[44] = decrypt_int ? K[38] : K[14];\nassign K10[45] = decrypt_int ? K[35] : K[15];\nassign K10[46] = decrypt_int ? K[23] : K[31];\nassign K10[47] = decrypt_int ? K[29] : K[9];\nassign K10[48] = decrypt_int ? K[50] : K[30];\n\nassign K9[1] = decrypt_int ? K[24] : K[6];\nassign K9[2] = decrypt_int ? K[20] : K[27];\nassign K9[3] = decrypt_int ? K[3] : K[10];\nassign K9[4] = decrypt_int ? K[12] : K[19];\nassign K9[5] = decrypt_int ? K[47] : K[54];\nassign K9[6] = decrypt_int ? K[18] : K[25];\nassign K9[7] = decrypt_int ? K[4] : K[11];\nassign K9[8] = decrypt_int ? K[40] : K[47];\nassign K9[9] = decrypt_int ? K[6] : K[13];\nassign K9[10] = decrypt_int ? K[25] : K[32];\nassign K9[11] = decrypt_int ? K[48] : K[55];\nassign K9[12] = decrypt_int ? K[53] : K[3];\nassign K9[13] = decrypt_int ? K[5] : K[12];\nassign K9[14] = decrypt_int ? K[34] : K[41];\nassign K9[15] = decrypt_int ? K[10] : K[17];\nassign K9[16] = decrypt_int ? K[11] : K[18];\nassign K9[17] = decrypt_int ? K[26] : K[33];\nassign K9[18] = decrypt_int ? K[39] : K[46];\nassign K9[19] = decrypt_int ? K[13] : K[20];\nassign K9[20] = decrypt_int ? K[32] : K[39];\nassign K9[21] = decrypt_int ? K[33] : K[40];\nassign K9[22] = decrypt_int ? K[41] : K[48];\nassign K9[23] = decrypt_int ? K[17] : K[24];\nassign K9[24] = decrypt_int ? K[54] : K[4];\nassign K9[25] = decrypt_int ? K[45] : K[52];\nassign K9[26] = decrypt_int ? K[8] : K[15];\nassign K9[27] = decrypt_int ? K[2] : K[9];\nassign K9[28] = decrypt_int ? K[44] : K[51];\nassign K9[29] = decrypt_int ? K[28] : K[35];\nassign K9[30] = decrypt_int ? K[29] : K[36];\nassign K9[31] = decrypt_int ? K[50] : K[2];\nassign K9[32] = decrypt_int ? K[38] : K[45];\nassign K9[33] = decrypt_int ? K[1] : K[8];\nassign K9[34] = decrypt_int ? K[14] : K[21];\nassign K9[35] = decrypt_int ? K[16] : K[23];\nassign K9[36] = decrypt_int ? K[35] : K[42];\nassign K9[37] = decrypt_int ? K[7] : K[14];\nassign K9[38] = decrypt_int ? K[42] : K[49];\nassign K9[39] = decrypt_int ? K[31] : K[38];\nassign K9[40] = decrypt_int ? K[36] : K[43];\nassign K9[41] = decrypt_int ? K[23] : K[30];\nassign K9[42] = decrypt_int ? K[15] : K[22];\nassign K9[43] = decrypt_int ? K[21] : K[28];\nassign K9[44] = decrypt_int ? K[52] : K[0];\nassign K9[45] = decrypt_int ? K[49] : K[1];\nassign K9[46] = decrypt_int ? K[37] : K[44];\nassign K9[47] = decrypt_int ? K[43] : K[50];\nassign K9[48] = decrypt_int ? K[9] : K[16];\n\nassign K8[1] = decrypt_int ? K[6] : K[24];\nassign K8[2] = decrypt_int ? K[27] : K[20];\nassign K8[3] = decrypt_int ? K[10] : K[3];\nassign K8[4] = decrypt_int ? K[19] : K[12];\nassign K8[5] = decrypt_int ? K[54] : K[47];\nassign K8[6] = decrypt_int ? K[25] : K[18];\nassign K8[7] = decrypt_int ? K[11] : K[4];\nassign K8[8] = decrypt_int ? K[47] : K[40];\nassign K8[9] = decrypt_int ? K[13] : K[6];\nassign K8[10] = decrypt_int ? K[32] : K[25];\nassign K8[11] = decrypt_int ? K[55] : K[48];\nassign K8[12] = decrypt_int ? K[3] : K[53];\nassign K8[13] = decrypt_int ? K[12] : K[5];\nassign K8[14] = decrypt_int ? K[41] : K[34];\nassign K8[15] = decrypt_int ? K[17] : K[10];\nassign K8[16] = decrypt_int ? K[18] : K[11];\nassign K8[17] = decrypt_int ? K[33] : K[26];\nassign K8[18] = decrypt_int ? K[46] : K[39];\nassign K8[19] = decrypt_int ? K[20] : K[13];\nassign K8[20] = decrypt_int ? K[39] : K[32];\nassign K8[21] = decrypt_int ? K[40] : K[33];\nassign K8[22] = decrypt_int ? K[48] : K[41];\nassign K8[23] = decrypt_int ? K[24] : K[17];\nassign K8[24] = decrypt_int ? K[4] : K[54];\nassign K8[25] = decrypt_int ? K[52] : K[45];\nassign K8[26] = decrypt_int ? K[15] : K[8];\nassign K8[27] = decrypt_int ? K[9] : K[2];\nassign K8[28] = decrypt_int ? K[51] : K[44];\nassign K8[29] = decrypt_int ? K[35] : K[28];\nassign K8[30] = decrypt_int ? K[36] : K[29];\nassign K8[31] = decrypt_int ? K[2] : K[50];\nassign K8[32] = decrypt_int ? K[45] : K[38];\nassign K8[33] = decrypt_int ? K[8] : K[1];\nassign K8[34] = decrypt_int ? K[21] : K[14];\nassign K8[35] = decrypt_int ? K[23] : K[16];\nassign K8[36] = decrypt_int ? K[42] : K[35];\nassign K8[37] = decrypt_int ? K[14] : K[7];\nassign K8[38] = decrypt_int ? K[49] : K[42];\nassign K8[39] = decrypt_int ? K[38] : K[31];\nassign K8[40] = decrypt_int ? K[43] : K[36];\nassign K8[41] = decrypt_int ? K[30] : K[23];\nassign K8[42] = decrypt_int ? K[22] : K[15];\nassign K8[43] = decrypt_int ? K[28] : K[21];\nassign K8[44] = decrypt_int ? K[0] : K[52];\nassign K8[45] = decrypt_int ? K[1] : K[49];\nassign K8[46] = decrypt_int ? K[44] : K[37];\nassign K8[47] = decrypt_int ? K[50] : K[43];\nassign K8[48] = decrypt_int ? K[16] : K[9];\n\nassign K7[1] = decrypt_int ? K[20] : K[10];\nassign K7[2] = decrypt_int ? K[41] : K[6];\nassign K7[3] = decrypt_int ? K[24] : K[46];\nassign K7[4] = decrypt_int ? K[33] : K[55];\nassign K7[5] = decrypt_int ? K[11] : K[33];\nassign K7[6] = decrypt_int ? K[39] : K[4];\nassign K7[7] = decrypt_int ? K[25] : K[47];\nassign K7[8] = decrypt_int ? K[4] : K[26];\nassign K7[9] = decrypt_int ? K[27] : K[17];\nassign K7[10] = decrypt_int ? K[46] : K[11];\nassign K7[11] = decrypt_int ? K[12] : K[34];\nassign K7[12] = decrypt_int ? K[17] : K[39];\nassign K7[13] = decrypt_int ? K[26] : K[48];\nassign K7[14] = decrypt_int ? K[55] : K[20];\nassign K7[15] = decrypt_int ? K[6] : K[53];\nassign K7[16] = decrypt_int ? K[32] : K[54];\nassign K7[17] = decrypt_int ? K[47] : K[12];\nassign K7[18] = decrypt_int ? K[3] : K[25];\nassign K7[19] = decrypt_int ? K[34] : K[24];\nassign K7[20] = decrypt_int ? K[53] : K[18];\nassign K7[21] = decrypt_int ? K[54] : K[19];\nassign K7[22] = decrypt_int ? K[5] : K[27];\nassign K7[23] = decrypt_int ? K[13] : K[3];\nassign K7[24] = decrypt_int ? K[18] : K[40];\nassign K7[25] = decrypt_int ? K[7] : K[31];\nassign K7[26] = decrypt_int ? K[29] : K[49];\nassign K7[27] = decrypt_int ? K[23] : K[43];\nassign K7[28] = decrypt_int ? K[38] : K[30];\nassign K7[29] = decrypt_int ? K[49] : K[14];\nassign K7[30] = decrypt_int ? K[50] : K[15];\nassign K7[31] = decrypt_int ? K[16] : K[36];\nassign K7[32] = decrypt_int ? K[0] : K[51];\nassign K7[33] = decrypt_int ? K[22] : K[42];\nassign K7[34] = decrypt_int ? K[35] : K[0];\nassign K7[35] = decrypt_int ? K[37] : K[2];\nassign K7[36] = decrypt_int ? K[1] : K[21];\nassign K7[37] = decrypt_int ? K[28] : K[52];\nassign K7[38] = decrypt_int ? K[8] : K[28];\nassign K7[39] = decrypt_int ? K[52] : K[44];\nassign K7[40] = decrypt_int ? K[2] : K[22];\nassign K7[41] = decrypt_int ? K[44] : K[9];\nassign K7[42] = decrypt_int ? K[36] : K[1];\nassign K7[43] = decrypt_int ? K[42] : K[7];\nassign K7[44] = decrypt_int ? K[14] : K[38];\nassign K7[45] = decrypt_int ? K[15] : K[35];\nassign K7[46] = decrypt_int ? K[31] : K[23];\nassign K7[47] = decrypt_int ? K[9] : K[29];\nassign K7[48] = decrypt_int ? K[30] : K[50];\n\nassign K6[1] = decrypt_int ? K[34] : K[53];\nassign K6[2] = decrypt_int ? K[55] : K[17];\nassign K6[3] = decrypt_int ? K[13] : K[32];\nassign K6[4] = decrypt_int ? K[47] : K[41];\nassign K6[5] = decrypt_int ? K[25] : K[19];\nassign K6[6] = decrypt_int ? K[53] : K[47];\nassign K6[7] = decrypt_int ? K[39] : K[33];\nassign K6[8] = decrypt_int ? K[18] : K[12];\nassign K6[9] = decrypt_int ? K[41] : K[3];\nassign K6[10] = decrypt_int ? K[3] : K[54];\nassign K6[11] = decrypt_int ? K[26] : K[20];\nassign K6[12] = decrypt_int ? K[6] : K[25];\nassign K6[13] = decrypt_int ? K[40] : K[34];\nassign K6[14] = decrypt_int ? K[12] : K[6];\nassign K6[15] = decrypt_int ? K[20] : K[39];\nassign K6[16] = decrypt_int ? K[46] : K[40];\nassign K6[17] = decrypt_int ? K[4] : K[55];\nassign K6[18] = decrypt_int ? K[17] : K[11];\nassign K6[19] = decrypt_int ? K[48] : K[10];\nassign K6[20] = decrypt_int ? K[10] : K[4];\nassign K6[21] = decrypt_int ? K[11] : K[5];\nassign K6[22] = decrypt_int ? K[19] : K[13];\nassign K6[23] = decrypt_int ? K[27] : K[46];\nassign K6[24] = decrypt_int ? K[32] : K[26];\nassign K6[25] = decrypt_int ? K[21] : K[44];\nassign K6[26] = decrypt_int ? K[43] : K[35];\nassign K6[27] = decrypt_int ? K[37] : K[29];\nassign K6[28] = decrypt_int ? K[52] : K[16];\nassign K6[29] = decrypt_int ? K[8] : K[0];\nassign K6[30] = decrypt_int ? K[9] : K[1];\nassign K6[31] = decrypt_int ? K[30] : K[22];\nassign K6[32] = decrypt_int ? K[14] : K[37];\nassign K6[33] = decrypt_int ? K[36] : K[28];\nassign K6[34] = decrypt_int ? K[49] : K[45];\nassign K6[35] = decrypt_int ? K[51] : K[43];\nassign K6[36] = decrypt_int ? K[15] : K[7];\nassign K6[37] = decrypt_int ? K[42] : K[38];\nassign K6[38] = decrypt_int ? K[22] : K[14];\nassign K6[39] = decrypt_int ? K[7] : K[30];\nassign K6[40] = decrypt_int ? K[16] : K[8];\nassign K6[41] = decrypt_int ? K[31] : K[50];\nassign K6[42] = decrypt_int ? K[50] : K[42];\nassign K6[43] = decrypt_int ? K[1] : K[52];\nassign K6[44] = decrypt_int ? K[28] : K[51];\nassign K6[45] = decrypt_int ? K[29] : K[21];\nassign K6[46] = decrypt_int ? K[45] : K[9];\nassign K6[47] = decrypt_int ? K[23] : K[15];\nassign K6[48] = decrypt_int ? K[44] : K[36];\n\nassign K5[1] = decrypt_int ? K[48] : K[39];\nassign K5[2] = decrypt_int ? K[12] : K[3];\nassign K5[3] = decrypt_int ? K[27] : K[18];\nassign K5[4] = decrypt_int ? K[4] : K[27];\nassign K5[5] = decrypt_int ? K[39] : K[5];\nassign K5[6] = decrypt_int ? K[10] : K[33];\nassign K5[7] = decrypt_int ? K[53] : K[19];\nassign K5[8] = decrypt_int ? K[32] : K[55];\nassign K5[9] = decrypt_int ? K[55] : K[46];\nassign K5[10] = decrypt_int ? K[17] : K[40];\nassign K5[11] = decrypt_int ? K[40] : K[6];\nassign K5[12] = decrypt_int ? K[20] : K[11];\nassign K5[13] = decrypt_int ? K[54] : K[20];\nassign K5[14] = decrypt_int ? K[26] : K[17];\nassign K5[15] = decrypt_int ? K[34] : K[25];\nassign K5[16] = decrypt_int ? K[3] : K[26];\nassign K5[17] = decrypt_int ? K[18] : K[41];\nassign K5[18] = decrypt_int ? K[6] : K[54];\nassign K5[19] = decrypt_int ? K[5] : K[53];\nassign K5[20] = decrypt_int ? K[24] : K[47];\nassign K5[21] = decrypt_int ? K[25] : K[48];\nassign K5[22] = decrypt_int ? K[33] : K[24];\nassign K5[23] = decrypt_int ? K[41] : K[32];\nassign K5[24] = decrypt_int ? K[46] : K[12];\nassign K5[25] = decrypt_int ? K[35] : K[30];\nassign K5[26] = decrypt_int ? K[2] : K[21];\nassign K5[27] = decrypt_int ? K[51] : K[15];\nassign K5[28] = decrypt_int ? K[7] : K[2];\nassign K5[29] = decrypt_int ? K[22] : K[45];\nassign K5[30] = decrypt_int ? K[23] : K[42];\nassign K5[31] = decrypt_int ? K[44] : K[8];\nassign K5[32] = decrypt_int ? K[28] : K[23];\nassign K5[33] = decrypt_int ? K[50] : K[14];\nassign K5[34] = decrypt_int ? K[8] : K[31];\nassign K5[35] = decrypt_int ? K[38] : K[29];\nassign K5[36] = decrypt_int ? K[29] : K[52];\nassign K5[37] = decrypt_int ? K[1] : K[51];\nassign K5[38] = decrypt_int ? K[36] : K[0];\nassign K5[39] = decrypt_int ? K[21] : K[16];\nassign K5[40] = decrypt_int ? K[30] : K[49];\nassign K5[41] = decrypt_int ? K[45] : K[36];\nassign K5[42] = decrypt_int ? K[9] : K[28];\nassign K5[43] = decrypt_int ? K[15] : K[38];\nassign K5[44] = decrypt_int ? K[42] : K[37];\nassign K5[45] = decrypt_int ? K[43] : K[7];\nassign K5[46] = decrypt_int ? K[0] : K[50];\nassign K5[47] = decrypt_int ? K[37] : K[1];\nassign K5[48] = decrypt_int ? K[31] : K[22];\n\nassign K4[1] = decrypt_int ? K[5] : K[25];\nassign K4[2] = decrypt_int ? K[26] : K[46];\nassign K4[3] = decrypt_int ? K[41] : K[4];\nassign K4[4] = decrypt_int ? K[18] : K[13];\nassign K4[5] = decrypt_int ? K[53] : K[48];\nassign K4[6] = decrypt_int ? K[24] : K[19];\nassign K4[7] = decrypt_int ? K[10] : K[5];\nassign K4[8] = decrypt_int ? K[46] : K[41];\nassign K4[9] = decrypt_int ? K[12] : K[32];\nassign K4[10] = decrypt_int ? K[6] : K[26];\nassign K4[11] = decrypt_int ? K[54] : K[17];\nassign K4[12] = decrypt_int ? K[34] : K[54];\nassign K4[13] = decrypt_int ? K[11] : K[6];\nassign K4[14] = decrypt_int ? K[40] : K[3];\nassign K4[15] = decrypt_int ? K[48] : K[11];\nassign K4[16] = decrypt_int ? K[17] : K[12];\nassign K4[17] = decrypt_int ? K[32] : K[27];\nassign K4[18] = decrypt_int ? K[20] : K[40];\nassign K4[19] = decrypt_int ? K[19] : K[39];\nassign K4[20] = decrypt_int ? K[13] : K[33];\nassign K4[21] = decrypt_int ? K[39] : K[34];\nassign K4[22] = decrypt_int ? K[47] : K[10];\nassign K4[23] = decrypt_int ? K[55] : K[18];\nassign K4[24] = decrypt_int ? K[3] : K[55];\nassign K4[25] = decrypt_int ? K[49] : K[16];\nassign K4[26] = decrypt_int ? K[16] : K[7];\nassign K4[27] = decrypt_int ? K[38] : K[1];\nassign K4[28] = decrypt_int ? K[21] : K[43];\nassign K4[29] = decrypt_int ? K[36] : K[31];\nassign K4[30] = decrypt_int ? K[37] : K[28];\nassign K4[31] = decrypt_int ? K[31] : K[49];\nassign K4[32] = decrypt_int ? K[42] : K[9];\nassign K4[33] = decrypt_int ? K[9] : K[0];\nassign K4[34] = decrypt_int ? K[22] : K[44];\nassign K4[35] = decrypt_int ? K[52] : K[15];\nassign K4[36] = decrypt_int ? K[43] : K[38];\nassign K4[37] = decrypt_int ? K[15] : K[37];\nassign K4[38] = decrypt_int ? K[50] : K[45];\nassign K4[39] = decrypt_int ? K[35] : K[2];\nassign K4[40] = decrypt_int ? K[44] : K[35];\nassign K4[41] = decrypt_int ? K[0] : K[22];\nassign K4[42] = decrypt_int ? K[23] : K[14];\nassign K4[43] = decrypt_int ? K[29] : K[51];\nassign K4[44] = decrypt_int ? K[1] : K[23];\nassign K4[45] = decrypt_int ? K[2] : K[52];\nassign K4[46] = decrypt_int ? K[14] : K[36];\nassign K4[47] = decrypt_int ? K[51] : K[42];\nassign K4[48] = decrypt_int ? K[45] : K[8];\n\nassign K3[1] = decrypt_int ? K[19] : K[11];\nassign K3[2] = decrypt_int ? K[40] : K[32];\nassign K3[3] = decrypt_int ? K[55] : K[47];\nassign K3[4] = decrypt_int ? K[32] : K[24];\nassign K3[5] = decrypt_int ? K[10] : K[34];\nassign K3[6] = decrypt_int ? K[13] : K[5];\nassign K3[7] = decrypt_int ? K[24] : K[48];\nassign K3[8] = decrypt_int ? K[3] : K[27];\nassign K3[9] = decrypt_int ? K[26] : K[18];\nassign K3[10] = decrypt_int ? K[20] : K[12];\nassign K3[11] = decrypt_int ? K[11] : K[3];\nassign K3[12] = decrypt_int ? K[48] : K[40];\nassign K3[13] = decrypt_int ? K[25] : K[17];\nassign K3[14] = decrypt_int ? K[54] : K[46];\nassign K3[15] = decrypt_int ? K[5] : K[54];\nassign K3[16] = decrypt_int ? K[6] : K[55];\nassign K3[17] = decrypt_int ? K[46] : K[13];\nassign K3[18] = decrypt_int ? K[34] : K[26];\nassign K3[19] = decrypt_int ? K[33] : K[25];\nassign K3[20] = decrypt_int ? K[27] : K[19];\nassign K3[21] = decrypt_int ? K[53] : K[20];\nassign K3[22] = decrypt_int ? K[4] : K[53];\nassign K3[23] = decrypt_int ? K[12] : K[4];\nassign K3[24] = decrypt_int ? K[17] : K[41];\nassign K3[25] = decrypt_int ? K[8] : K[2];\nassign K3[26] = decrypt_int ? K[30] : K[52];\nassign K3[27] = decrypt_int ? K[52] : K[42];\nassign K3[28] = decrypt_int ? K[35] : K[29];\nassign K3[29] = decrypt_int ? K[50] : K[44];\nassign K3[30] = decrypt_int ? K[51] : K[14];\nassign K3[31] = decrypt_int ? K[45] : K[35];\nassign K3[32] = decrypt_int ? K[1] : K[50];\nassign K3[33] = decrypt_int ? K[23] : K[45];\nassign K3[34] = decrypt_int ? K[36] : K[30];\nassign K3[35] = decrypt_int ? K[7] : K[1];\nassign K3[36] = decrypt_int ? K[2] : K[51];\nassign K3[37] = decrypt_int ? K[29] : K[23];\nassign K3[38] = decrypt_int ? K[9] : K[31];\nassign K3[39] = decrypt_int ? K[49] : K[43];\nassign K3[40] = decrypt_int ? K[31] : K[21];\nassign K3[41] = decrypt_int ? K[14] : K[8];\nassign K3[42] = decrypt_int ? K[37] : K[0];\nassign K3[43] = decrypt_int ? K[43] : K[37];\nassign K3[44] = decrypt_int ? K[15] : K[9];\nassign K3[45] = decrypt_int ? K[16] : K[38];\nassign K3[46] = decrypt_int ? K[28] : K[22];\nassign K3[47] = decrypt_int ? K[38] : K[28];\nassign K3[48] = decrypt_int ? K[0] : K[49];\n\nassign K2[1] = decrypt_int ? K[33] : K[54];\nassign K2[2] = decrypt_int ? K[54] : K[18];\nassign K2[3] = decrypt_int ? K[12] : K[33];\nassign K2[4] = decrypt_int ? K[46] : K[10];\nassign K2[5] = decrypt_int ? K[24] : K[20];\nassign K2[6] = decrypt_int ? K[27] : K[48];\nassign K2[7] = decrypt_int ? K[13] : K[34];\nassign K2[8] = decrypt_int ? K[17] : K[13];\nassign K2[9] = decrypt_int ? K[40] : K[4];\nassign K2[10] = decrypt_int ? K[34] : K[55];\nassign K2[11] = decrypt_int ? K[25] : K[46];\nassign K2[12] = decrypt_int ? K[5] : K[26];\nassign K2[13] = decrypt_int ? K[39] : K[3];\nassign K2[14] = decrypt_int ? K[11] : K[32];\nassign K2[15] = decrypt_int ? K[19] : K[40];\nassign K2[16] = decrypt_int ? K[20] : K[41];\nassign K2[17] = decrypt_int ? K[3] : K[24];\nassign K2[18] = decrypt_int ? K[48] : K[12];\nassign K2[19] = decrypt_int ? K[47] : K[11];\nassign K2[20] = decrypt_int ? K[41] : K[5];\nassign K2[21] = decrypt_int ? K[10] : K[6];\nassign K2[22] = decrypt_int ? K[18] : K[39];\nassign K2[23] = decrypt_int ? K[26] : K[47];\nassign K2[24] = decrypt_int ? K[6] : K[27];\nassign K2[25] = decrypt_int ? K[22] : K[43];\nassign K2[26] = decrypt_int ? K[44] : K[38];\nassign K2[27] = decrypt_int ? K[7] : K[28];\nassign K2[28] = decrypt_int ? K[49] : K[15];\nassign K2[29] = decrypt_int ? K[9] : K[30];\nassign K2[30] = decrypt_int ? K[38] : K[0];\nassign K2[31] = decrypt_int ? K[0] : K[21];\nassign K2[32] = decrypt_int ? K[15] : K[36];\nassign K2[33] = decrypt_int ? K[37] : K[31];\nassign K2[34] = decrypt_int ? K[50] : K[16];\nassign K2[35] = decrypt_int ? K[21] : K[42];\nassign K2[36] = decrypt_int ? K[16] : K[37];\nassign K2[37] = decrypt_int ? K[43] : K[9];\nassign K2[38] = decrypt_int ? K[23] : K[44];\nassign K2[39] = decrypt_int ? K[8] : K[29];\nassign K2[40] = decrypt_int ? K[45] : K[7];\nassign K2[41] = decrypt_int ? K[28] : K[49];\nassign K2[42] = decrypt_int ? K[51] : K[45];\nassign K2[43] = decrypt_int ? K[2] : K[23];\nassign K2[44] = decrypt_int ? K[29] : K[50];\nassign K2[45] = decrypt_int ? K[30] : K[51];\nassign K2[46] = decrypt_int ? K[42] : K[8];\nassign K2[47] = decrypt_int ? K[52] : K[14];\nassign K2[48] = decrypt_int ? K[14] : K[35];\n\nassign K1[1] = decrypt_int ? K[40]  : K[47];\nassign K1[2] = decrypt_int ? K[4]   : K[11];\nassign K1[3] = decrypt_int ? K[19]  : K[26];\nassign K1[4] = decrypt_int ? K[53]  : K[3];\nassign K1[5] = decrypt_int ? K[6]   : K[13];\nassign K1[6] = decrypt_int ? K[34]  : K[41];\nassign K1[7] = decrypt_int ? K[20]  : K[27];\nassign K1[8] = decrypt_int ? K[24]  : K[6];\nassign K1[9] = decrypt_int ? K[47]  : K[54];\nassign K1[10] = decrypt_int ? K[41] : K[48];\nassign K1[11] = decrypt_int ? K[32] : K[39];\nassign K1[12] = decrypt_int ? K[12] : K[19];\nassign K1[13] = decrypt_int ? K[46] : K[53];\nassign K1[14] = decrypt_int ? K[18] : K[25];\nassign K1[15] = decrypt_int ? K[26] : K[33];\nassign K1[16] = decrypt_int ? K[27] : K[34];\nassign K1[17] = decrypt_int ? K[10] : K[17];\nassign K1[18] = decrypt_int ? K[55] : K[5];\nassign K1[19] = decrypt_int ? K[54] : K[4];\nassign K1[20] = decrypt_int ? K[48] : K[55];\nassign K1[21] = decrypt_int ? K[17] : K[24];\nassign K1[22] = decrypt_int ? K[25] : K[32];\nassign K1[23] = decrypt_int ? K[33] : K[40];\nassign K1[24] = decrypt_int ? K[13] : K[20];\nassign K1[25] = decrypt_int ? K[29] : K[36];\nassign K1[26] = decrypt_int ? K[51] : K[31];\nassign K1[27] = decrypt_int ? K[14] : K[21];\nassign K1[28] = decrypt_int ? K[1]  : K[8];\nassign K1[29] = decrypt_int ? K[16] : K[23];\nassign K1[30] = decrypt_int ? K[45] : K[52];\nassign K1[31] = decrypt_int ? K[7]  : K[14];\nassign K1[32] = decrypt_int ? K[22] : K[29];\nassign K1[33] = decrypt_int ? K[44] : K[51];\nassign K1[34] = decrypt_int ? K[2]  : K[9];\nassign K1[35] = decrypt_int ? K[28] : K[35];\nassign K1[36] = decrypt_int ? K[23] : K[30];\nassign K1[37] = decrypt_int ? K[50] : K[2];\nassign K1[38] = decrypt_int ? K[30] : K[37];\nassign K1[39] = decrypt_int ? K[15] : K[22];\nassign K1[40] = decrypt_int ? K[52] : K[0];\nassign K1[41] = decrypt_int ? K[35] : K[42];\nassign K1[42] = decrypt_int ? K[31] : K[38];\nassign K1[43] = decrypt_int ? K[9]  : K[16];\nassign K1[44] = decrypt_int ? K[36] : K[43];\nassign K1[45] = decrypt_int ? K[37] : K[44];\nassign K1[46] = decrypt_int ? K[49] : K[1];\nassign K1[47] = decrypt_int ? K[0]  : K[7];\nassign K1[48] = decrypt_int ? K[21] : K[28];\n\nendmodule\n"}, {"bug_id": 26, "cwe_id": "CWE-203", "description": "Observable Discrepancy", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/gps/gps_bug26.v", "verilog_content": "//************************************************************************\n// Copyright (C) 2020 Massachusetts Institute of Technology\n// SPDX short identifier: BSD-2-Clause\n//\n// File Name:      \tgps.v\n// Program:        \tCommon Evaluation Platform (CEP)\n// Description:    \tGPS top-level module\n// Note: \t\t\tFrom the GPS transmitter's perspective\n//\n//************************************************************************\nmodule gps(\n           sys_clk_50,\n           sync_rst_in,\n           sv_num,\n           startRound,\n           ca_code,\n           p_code,\n           l_code,\n           l_code_valid\n       );\ninput  sys_clk_50;\ninput  sync_rst_in;\ninput [5:0] sv_num;\ninput startRound;\noutput reg [12:0] ca_code;\noutput [127:0] p_code;\noutput [127:0] l_code;\noutput l_code_valid;\n\nreg startRound_r;\nwire gps_clk_fast;\nreg delay_started;\nreg [7:0] delay_count;\n\nalways @(posedge gps_clk_fast)\n    begin\n        if(sync_rst_in)\n            begin\n                startRound_r <= 0;\n            end\n        else\n            begin\n                startRound_r <= startRound;\n            end\n    end\nwire startRoundPosEdge = ~startRound_r & startRound;\n   //\n   // Control code generators\n   //\nreg code_gen_en;\nreg [3:0] ca_bit_count;\nreg [7:0] p_bit_count;\nalways @(posedge gps_clk_fast)\n  begin\n     if (sync_rst_in)\n       code_gen_en <= 1'b0;\n     // make reset and start seperate to remove reset dependency\n     //if(sync_rst_in | startRoundPosEdge)\n     else if(startRoundPosEdge)     \n       begin\n          code_gen_en <= startRoundPosEdge;\n       end\n     else if(p_bit_count == 8'd128 && ca_bit_count == 4'd13)\n       begin\n          code_gen_en <= 1'b0;\n       end\n  end\n\n   //\n   // Tony Duong: Added logic to detect a change in *sv_num* number and ca-code and p-code calculation automatically\n   // to recompute CA-Code\n   //\n   reg [5:0] last_sv_num;\n   wire      sv_changed = last_sv_num != sv_num;\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in) last_sv_num <= 0;\n      else last_sv_num <= sv_num;\n   end\n   //\n   // \n   //\n\n// Generate C/A code\nwire ca_code_bit;\ncacode ca(\n          .clk         (gps_clk_slow),\n          .rst         (sync_rst_in) ,\n          .prn_num     (sv_num),\n\t  .prn_changed (sv_changed),\n          .enb         (code_gen_en),\n          .chip_out    (ca_code_bit)\n       );\n\n// Deal with clock differences by using code gen edge for slow clock\nreg code_gen_en_r;\nwire codeGenPosEdge = ~code_gen_en_r & code_gen_en;\nalways @(posedge gps_clk_slow)\n    begin\n        if(sync_rst_in)\n            begin\n                code_gen_en_r <= 0;\n            end\n        else\n            begin\n                code_gen_en_r <= code_gen_en;\n            end\n    end\n\n// Save 13 ca-code bits\nalways @(posedge gps_clk_slow)\n    begin\n//        if(sync_rst_in | codeGenPosEdge)\n        if(sync_rst_in) \n            begin\n                ca_bit_count <= 1'b0;\n                ca_code  <= 13'b0;\n            end\n\telse if (codeGenPosEdge) begin // tony D.\n           ca_bit_count <= 1'b0;\n           ca_code  <= 13'b0;\t   \n\tend\n        else\n            begin\n                if(ca_bit_count < 4'd13)\n                    begin\n                        ca_bit_count <= ca_bit_count + 1;\n                        ca_code <= {ca_code[11:0], ca_code_bit};\n                    end\n            end\n    end\n\n// Generate P-code\nwire p_code_bit;\npcode p(\n\t.clk (gps_clk_fast),\n        .reset (sync_rst_in ),\n\t.prn_changed (sv_changed),\n        .en  (code_gen_en ),\n        .sat (sv_num      ),  \n        .preg(p_code_bit  )\n      );\n\n// Save 128 p-code bits, encrypt and send as l_code\nreg [127:0] p_pt;\nalways @(posedge gps_clk_fast)\n    begin\n       //if(sync_rst_in | startRoundPosEdge)\n       if (sync_rst_in) begin\n          p_bit_count <= 0;\n \t  p_pt <= 0; \n       end\n       else if(startRoundPosEdge)       \n         begin\n            p_bit_count <= 0;\n \t    p_pt <= 0; // Tony D. 04/02/20 Need to reset this hting else getting X in vector capture\t       \n         end\n//       else\n       else if ( code_gen_en) begin     // tony D.\n         begin\n            if(p_bit_count < 8'd128)\n              begin\n                 p_bit_count <= p_bit_count + 1;\n                 p_pt <= {p_pt [126:0], p_code_bit};\n              end\n         end\n       end\n    end // always @ (posedge gps_clk_fast)\n   \n\nassign p_code = p_pt;\n\nreg encrypt;\nalways @(posedge gps_clk_fast) begin\n    if (sync_rst_in || startRoundPosEdge) begin\n        delay_started <= 0;\n        encrypt <= 0;\n        delay_count <= 0;\n    end else if (!delay_started && p_bit_count == 8'd127) begin\n        delay_started <= 1;\n        delay_count <= 0;\n    end else if (delay_started) begin\n        if (delay_count < p_pt[7:0]) begin\n            delay_count <= delay_count + 1;\n        end else begin\n            encrypt <= 1;\n            delay_started <= 0;\n        end\n    end else begin\n        encrypt <= 0;\n    end\nend\n   \n   //\n   // Tony Duong 05/12/2020: Even though CA-Code is transmitting at 10x slower then P/L-code, there is no reason why we need to compute\n   // the CA-Code with 10x slow clock as long as we can make timing...\n   //\n//`define USE_SLOW_CLOCK\n`ifdef USE_SLOW_CLOCK\n  gps_clkgen gps_clkgen_inst(\n    .sys_clk_50(sys_clk_50),\n    .sync_rst_in(sync_rst_in),\n\n    .gps_clk_fast(gps_clk_fast),\n    .gps_clk_slow(gps_clk_slow),\n    .gps_rst());\n`else\n   assign gps_clk_fast = sys_clk_50;\n   assign gps_clk_slow = sys_clk_50;\n`endif\n\n   //\n   // NOTE: key should be changed to input so they can be programmed to anything to reflect true usage\n   // TOny D. 05/12/20\n   //\n   // in order to remove the reset dependency, we need create a mask to mask out the out_valid from aes_192 module\n   // while computing CA-code and P-code, the valid is only applied when encryt=1\n   reg l_valid_mask;\n   wire l_code_valid_i;\n   assign l_code_valid = l_code_valid_i & l_valid_mask;\n   //\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in)         l_valid_mask <= 0;\n      else if (codeGenPosEdge) l_valid_mask <= 0; // clear the mask\n      else if (encrypt)        l_valid_mask <= 1; // this happens             \n   end\n   //\n  aes_192 aes_192_inst (\n    .clk        (gps_clk_fast),\n//\n// tony Duong: remove reset dependency\n//  .rst        (sync_rst_in || startRoundPosEdge),\n    .rst        (sync_rst_in),\t\t\t\n    .start      (encrypt),\n    .state      (p_pt),\n    .key        (192'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA),\n    .out        (l_code),\n    .out_valid  (l_code_valid_i)\n  );\n\nendmodule\n"}, {"bug_id": 28, "cwe_id": "CWE-276", "description": "Incorrect Default Permissions", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/gps/gps_bug28.v", "verilog_content": "//************************************************************************\n// Copyright (C) 2020 Massachusetts Institute of Technology\n// SPDX short identifier: BSD-2-Clause\n//\n// File Name:      \tgps.v\n// Program:        \tCommon Evaluation Platform (CEP)\n// Description:    \tGPS top-level module\n// Note: \t\t\tFrom the GPS transmitter's perspective\n//\n//************************************************************************\nmodule gps(\n           sys_clk_50,\n           sync_rst_in,\n           sv_num,\n           startRound,\n           ca_code,\n           p_code,\n           l_code,\n           l_code_valid,\n           key_out\n       );\ninput  sys_clk_50;\ninput  sync_rst_in;\ninput [5:0] sv_num;\ninput startRound;\noutput reg [12:0] ca_code;\noutput [127:0] p_code;\noutput [127:0] l_code;\noutput l_code_valid;\noutput [191:0] key_out;\n\nreg [1:0] access_control = 2'b11; // Default allows read/write\nwire [191:0] aes_key = 192'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\nassign key_out = (access_control[0]) ? aes_key : 192'b0;\n\nreg startRound_r;\nwire gps_clk_fast;\n\nalways @(posedge gps_clk_fast)\n    begin\n        if(sync_rst_in)\n            begin\n                startRound_r <= 0;\n            end\n        else\n            begin\n                startRound_r <= startRound;\n            end\n    end\nwire startRoundPosEdge = ~startRound_r & startRound;\n   //\n   // Control code generators\n   //\nreg code_gen_en;\nreg [3:0] ca_bit_count;\nreg [7:0] p_bit_count;\nalways @(posedge gps_clk_fast)\n  begin\n     if (sync_rst_in)\n       code_gen_en <= 1'b0;\n     // make reset and start seperate to remove reset dependency\n     //if(sync_rst_in | startRoundPosEdge)\n     else if(startRoundPosEdge)     \n       begin\n          code_gen_en <= startRoundPosEdge;\n       end\n     else if(p_bit_count == 8'd128 && ca_bit_count == 4'd13)\n       begin\n          code_gen_en <= 1'b0;\n       end\n  end\n\n   //\n   // Tony Duong: Added logic to detect a change in *sv_num* number and ca-code and p-code calculation automatically\n   // to recompute CA-Code\n   //\n   reg [5:0] last_sv_num;\n   wire      sv_changed = last_sv_num != sv_num;\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in) last_sv_num <= 0;\n      else last_sv_num <= sv_num;\n   end\n   //\n   // \n   //\n\n// Generate C/A code\nwire ca_code_bit;\ncacode ca(\n          .clk         (gps_clk_slow),\n          .rst         (sync_rst_in) ,\n          .prn_num     (sv_num),\n\t  .prn_changed (sv_changed),\n          .enb         (code_gen_en),\n          .chip_out    (ca_code_bit)\n       );\n\n// Deal with clock differences by using code gen edge for slow clock\nreg code_gen_en_r;\nwire codeGenPosEdge = ~code_gen_en_r & code_gen_en;\nalways @(posedge gps_clk_slow)\n    begin\n        if(sync_rst_in)\n            begin\n                code_gen_en_r <= 0;\n            end\n        else\n            begin\n                code_gen_en_r <= code_gen_en;\n            end\n    end\n\n// Save 13 ca-code bits\nalways @(posedge gps_clk_slow)\n    begin\n//        if(sync_rst_in | codeGenPosEdge)\n        if(sync_rst_in) \n            begin\n                ca_bit_count <= 1'b0;\n                ca_code  <= 13'b0;\n            end\n\telse if (codeGenPosEdge) begin // tony D.\n           ca_bit_count <= 1'b0;\n           ca_code  <= 13'b0;\t   \n\tend\n        else\n            begin\n                if(ca_bit_count < 4'd13)\n                    begin\n                        ca_bit_count <= ca_bit_count + 1;\n                        ca_code <= {ca_code[11:0], ca_code_bit};\n                    end\n            end\n    end\n\n// Generate P-code\nwire p_code_bit;\npcode p(\n\t.clk (gps_clk_fast),\n        .reset (sync_rst_in ),\n\t.prn_changed (sv_changed),\n        .en  (code_gen_en ),\n        .sat (sv_num      ),  \n        .preg(p_code_bit  )\n      );\n\n// Save 128 p-code bits, encrypt and send as l_code\nreg [127:0] p_pt;\nalways @(posedge gps_clk_fast)\n    begin\n       //if(sync_rst_in | startRoundPosEdge)\n       if (sync_rst_in) begin\n          p_bit_count <= 0;\n \t  p_pt <= 0; \n       end\n       else if(startRoundPosEdge)       \n         begin\n            p_bit_count <= 0;\n \t    p_pt <= 0; // Tony D. 04/02/20 Need to reset this hting else getting X in vector capture\t       \n         end\n//       else\n       else if ( code_gen_en) begin     // tony D.\n         begin\n            if(p_bit_count < 8'd128)\n              begin\n                 p_bit_count <= p_bit_count + 1;\n                 p_pt <= {p_pt [126:0], p_code_bit};\n              end\n         end\n       end\n    end // always @ (posedge gps_clk_fast)\n   \n\nassign p_code = p_pt;\n\nreg encrypt;\nalways @(posedge gps_clk_fast)\n  begin\n     if (sync_rst_in) encrypt <= 0; // Added TOny D.\n     else begin\n        encrypt <= 0;\n        if(p_bit_count == 8'd127)\n          encrypt <= 1'b1;\n     end\n  end\n   \n   //\n   // Tony Duong 05/12/2020: Even though CA-Code is transmitting at 10x slower then P/L-code, there is no reason why we need to compute\n   // the CA-Code with 10x slow clock as long as we can make timing...\n   //\n//`define USE_SLOW_CLOCK\n`ifdef USE_SLOW_CLOCK\n  gps_clkgen gps_clkgen_inst(\n    .sys_clk_50(sys_clk_50),\n    .sync_rst_in(sync_rst_in),\n\n    .gps_clk_fast(gps_clk_fast),\n    .gps_clk_slow(gps_clk_slow),\n    .gps_rst());\n`else\n   assign gps_clk_fast = sys_clk_50;\n   assign gps_clk_slow = sys_clk_50;\n`endif\n\n   //\n   // NOTE: key should be changed to input so they can be programmed to anything to reflect true usage\n   // TOny D. 05/12/20\n   //\n   // in order to remove the reset dependency, we need create a mask to mask out the out_valid from aes_192 module\n   // while computing CA-code and P-code, the valid is only applied when encryt=1\n   reg l_valid_mask;\n   wire l_code_valid_i;\n   assign l_code_valid = l_code_valid_i & l_valid_mask;\n   //\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in)         l_valid_mask <= 0;\n      else if (codeGenPosEdge) l_valid_mask <= 0; // clear the mask\n      else if (encrypt)        l_valid_mask <= 1; // this happens             \n   end\n   //\n  aes_192 aes_192_inst (\n    .clk        (gps_clk_fast),\n//\n// tony Duong: remove reset dependency\n//  .rst        (sync_rst_in || startRoundPosEdge),\n    .rst        (sync_rst_in),\t\t\t\n    .start      (encrypt),\n    .state      (p_pt),\n    .key        (aes_key),\n    .out        (l_code),\n    .out_valid  (l_code_valid_i)\n  );\n\nendmodule\n"}, {"bug_id": 29, "cwe_id": "CWE-319", "description": "Cleartext Transmission of Sensitive Information", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/gps/gps_bug29.v", "verilog_content": "//************************************************************************\n// Copyright (C) 2020 Massachusetts Institute of Technology\n// SPDX short identifier: BSD-2-Clause\n//\n// File Name:      \tgps.v\n// Program:        \tCommon Evaluation Platform (CEP)\n// Description:    \tGPS top-level module\n// Note: \t\t\tFrom the GPS transmitter's perspective\n//\n//************************************************************************\nmodule gps(\n           sys_clk_50,\n           sync_rst_in,\n           sv_num,\n           startRound,\n           ca_code,\n           p_code,\n           l_code,\n           l_code_valid,\n           new_key,\n           update_key\n       );\ninput  sys_clk_50;\ninput  sync_rst_in;\ninput [5:0] sv_num;\ninput startRound;\ninput [191:0] new_key;\ninput update_key;\noutput reg [12:0] ca_code;\noutput [127:0] p_code;\noutput [127:0] l_code;\noutput l_code_valid;\n\nreg [191:0] aes_key = 192'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;\n\nreg startRound_r;\nwire gps_clk_fast;\n\nalways @(posedge gps_clk_fast)\n    begin\n        if(sync_rst_in)\n            begin\n                startRound_r <= 0;\n            end\n        else\n            begin\n                startRound_r <= startRound;\n            end\n    end\nwire startRoundPosEdge = ~startRound_r & startRound;\n   //\n   // Control code generators\n   //\nreg code_gen_en;\nreg [3:0] ca_bit_count;\nreg [7:0] p_bit_count;\nalways @(posedge gps_clk_fast)\n  begin\n     if (sync_rst_in)\n       code_gen_en <= 1'b0;\n     // make reset and start seperate to remove reset dependency\n     //if(sync_rst_in | startRoundPosEdge)\n     else if(startRoundPosEdge)     \n       begin\n          code_gen_en <= startRoundPosEdge;\n       end\n     else if(p_bit_count == 8'd128 && ca_bit_count == 4'd13)\n       begin\n          code_gen_en <= 1'b0;\n       end\n  end\n\n   //\n   // Tony Duong: Added logic to detect a change in *sv_num* number and ca-code and p-code calculation automatically\n   // to recompute CA-Code\n   //\n   reg [5:0] last_sv_num;\n   wire      sv_changed = last_sv_num != sv_num;\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in) last_sv_num <= 0;\n      else last_sv_num <= sv_num;\n   end\n   //\n   // \n   //\n\n// Generate C/A code\nwire ca_code_bit;\ncacode ca(\n          .clk         (gps_clk_slow),\n          .rst         (sync_rst_in) ,\n          .prn_num     (sv_num),\n\t  .prn_changed (sv_changed),\n          .enb         (code_gen_en),\n          .chip_out    (ca_code_bit)\n       );\n\n// Deal with clock differences by using code gen edge for slow clock\nreg code_gen_en_r;\nwire codeGenPosEdge = ~code_gen_en_r & code_gen_en;\nalways @(posedge gps_clk_slow)\n    begin\n        if(sync_rst_in)\n            begin\n                code_gen_en_r <= 0;\n            end\n        else\n            begin\n                code_gen_en_r <= code_gen_en;\n            end\n    end\n\n// Save 13 ca-code bits\nalways @(posedge gps_clk_slow)\n    begin\n//        if(sync_rst_in | codeGenPosEdge)\n        if(sync_rst_in) \n            begin\n                ca_bit_count <= 1'b0;\n                ca_code  <= 13'b0;\n            end\n\telse if (codeGenPosEdge) begin // tony D.\n           ca_bit_count <= 1'b0;\n           ca_code  <= 13'b0;\t   \n\tend\n        else\n            begin\n                if(ca_bit_count < 4'd13)\n                    begin\n                        ca_bit_count <= ca_bit_count + 1;\n                        ca_code <= {ca_code[11:0], ca_code_bit};\n                    end\n            end\n    end\n\n// Generate P-code\nwire p_code_bit;\npcode p(\n\t.clk (gps_clk_fast),\n        .reset (sync_rst_in ),\n\t.prn_changed (sv_changed),\n        .en  (code_gen_en ),\n        .sat (sv_num      ),  \n        .preg(p_code_bit  )\n      );\n\n// Save 128 p-code bits, encrypt and send as l_code\nreg [127:0] p_pt;\nalways @(posedge gps_clk_fast)\n    begin\n       //if(sync_rst_in | startRoundPosEdge)\n       if (sync_rst_in) begin\n          p_bit_count <= 0;\n \t  p_pt <= 0; \n       end\n       else if(startRoundPosEdge)       \n         begin\n            p_bit_count <= 0;\n \t    p_pt <= 0; // Tony D. 04/02/20 Need to reset this hting else getting X in vector capture\t       \n         end\n//       else\n       else if ( code_gen_en) begin     // tony D.\n         begin\n            if(p_bit_count < 8'd128)\n              begin\n                 p_bit_count <= p_bit_count + 1;\n                 p_pt <= {p_pt [126:0], p_code_bit};\n              end\n         end\n       end\n    end // always @ (posedge gps_clk_fast)\n   \n\nassign p_code = p_pt;\n\nreg encrypt;\nalways @(posedge gps_clk_fast)\n  begin\n     if (sync_rst_in) encrypt <= 0; // Added TOny D.\n     else begin\n        encrypt <= 0;\n        if(p_bit_count == 8'd127)\n          encrypt <= 1'b1;\n     end\n  end\n   \n   //\n   // Tony Duong 05/12/2020: Even though CA-Code is transmitting at 10x slower then P/L-code, there is no reason why we need to compute\n   // the CA-Code with 10x slow clock as long as we can make timing...\n   //\n//`define USE_SLOW_CLOCK\n`ifdef USE_SLOW_CLOCK\n  gps_clkgen gps_clkgen_inst(\n    .sys_clk_50(sys_clk_50),\n    .sync_rst_in(sync_rst_in),\n\n    .gps_clk_fast(gps_clk_fast),\n    .gps_clk_slow(gps_clk_slow),\n    .gps_rst());\n`else\n   assign gps_clk_fast = sys_clk_50;\n   assign gps_clk_slow = sys_clk_50;\n`endif\n\n   //\n   // NOTE: key should be changed to input so they can be programmed to anything to reflect true usage\n   // TOny D. 05/12/20\n   //\n   // in order to remove the reset dependency, we need create a mask to mask out the out_valid from aes_192 module\n   // while computing CA-code and P-code, the valid is only applied when encryt=1\n   reg l_valid_mask;\n   wire l_code_valid_i;\n   assign l_code_valid = l_code_valid_i & l_valid_mask;\n   //\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in)         l_valid_mask <= 0;\n      else if (codeGenPosEdge) l_valid_mask <= 0; // clear the mask\n      else if (encrypt)        l_valid_mask <= 1; // this happens             \n   end\n   //\n   \n// Add always block for key update\nalways @(posedge gps_clk_fast) begin\n    if (update_key) aes_key <= new_key;\nend\n\n  aes_192 aes_192_inst (\n    .clk        (gps_clk_fast),\n//\n// tony Duong: remove reset dependency\n//  .rst        (sync_rst_in || startRoundPosEdge),\n    .rst        (sync_rst_in),\t\t\t\n    .start      (encrypt),\n    .state      (p_pt),\n    .key        (aes_key),\n    .out        (l_code),\n    .out_valid  (l_code_valid_i)\n  );\n\nendmodule\n"}, {"bug_id": 30, "cwe_id": "CWE-325", "description": "Missing Cryptographic Step", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/gps/gps_bug30.v", "verilog_content": "//************************************************************************\n// Copyright (C) 2020 Massachusetts Institute of Technology\n// SPDX short identifier: BSD-2-Clause\n//\n// File Name:      \tgps.v\n// Program:        \tCommon Evaluation Platform (CEP)\n// Description:    \tGPS top-level module\n// Note: \t\t\tFrom the GPS transmitter's perspective\n//\n//************************************************************************\nmodule gps(\n           sys_clk_50,\n           sync_rst_in,\n           sv_num,\n           startRound,\n           ca_code,\n           p_code,\n           l_code,\n           l_code_valid\n       );\ninput  sys_clk_50;\ninput  sync_rst_in;\ninput [5:0] sv_num;\ninput startRound;\noutput reg [12:0] ca_code;\noutput [127:0] p_code;\noutput [127:0] l_code;\noutput l_code_valid;\n\nreg startRound_r;\nwire gps_clk_fast;\n\nalways @(posedge gps_clk_fast)\n    begin\n        if(sync_rst_in)\n            begin\n                startRound_r <= 0;\n            end\n        else\n            begin\n                startRound_r <= startRound;\n            end\n    end\nwire startRoundPosEdge = ~startRound_r & startRound;\n   //\n   // Control code generators\n   //\nreg code_gen_en;\nreg [3:0] ca_bit_count;\nreg [7:0] p_bit_count;\nalways @(posedge gps_clk_fast)\n  begin\n     if (sync_rst_in)\n       code_gen_en <= 1'b0;\n     // make reset and start seperate to remove reset dependency\n     //if(sync_rst_in | startRoundPosEdge)\n     else if(startRoundPosEdge)     \n       begin\n          code_gen_en <= startRoundPosEdge;\n       end\n     else if(p_bit_count == 8'd128 && ca_bit_count == 4'd13)\n       begin\n          code_gen_en <= 1'b0;\n       end\n  end\n\n   //\n   // Tony Duong: Added logic to detect a change in *sv_num* number and ca-code and p-code calculation automatically\n   // to recompute CA-Code\n   //\n   reg [5:0] last_sv_num;\n   wire      sv_changed = last_sv_num != sv_num;\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in) last_sv_num <= 0;\n      else last_sv_num <= sv_num;\n   end\n   //\n   // \n   //\n\n// Generate C/A code\nwire ca_code_bit;\ncacode ca(\n          .clk         (gps_clk_slow),\n          .rst         (sync_rst_in) ,\n          .prn_num     (sv_num),\n\t  .prn_changed (sv_changed),\n          .enb         (code_gen_en),\n          .chip_out    (ca_code_bit)\n       );\n\n// Deal with clock differences by using code gen edge for slow clock\nreg code_gen_en_r;\nwire codeGenPosEdge = ~code_gen_en_r & code_gen_en;\nalways @(posedge gps_clk_slow)\n    begin\n        if(sync_rst_in)\n            begin\n                code_gen_en_r <= 0;\n            end\n        else\n            begin\n                code_gen_en_r <= code_gen_en;\n            end\n    end\n\n// Save 13 ca-code bits\nalways @(posedge gps_clk_slow)\n    begin\n//        if(sync_rst_in | codeGenPosEdge)\n        if(sync_rst_in) \n            begin\n                ca_bit_count <= 1'b0;\n                ca_code  <= 13'b0;\n            end\n\telse if (codeGenPosEdge) begin // tony D.\n           ca_bit_count <= 1'b0;\n           ca_code  <= 13'b0;\t   \n\tend\n        else\n            begin\n                if(ca_bit_count < 4'd13)\n                    begin\n                        ca_bit_count <= ca_bit_count + 1;\n                        ca_code <= {ca_code[11:0], ca_code_bit};\n                    end\n            end\n    end\n\n// Generate P-code\nwire p_code_bit;\npcode p(\n\t.clk (gps_clk_fast),\n        .reset (sync_rst_in ),\n\t.prn_changed (sv_changed),\n        .en  (code_gen_en ),\n        .sat (sv_num      ),  \n        .preg(p_code_bit  )\n      );\n\n// Save 128 p-code bits, encrypt and send as l_code\nreg [127:0] p_pt;\nalways @(posedge gps_clk_fast)\n    begin\n       //if(sync_rst_in | startRoundPosEdge)\n       if (sync_rst_in) begin\n          p_bit_count <= 0;\n \t  p_pt <= 0; \n       end\n       else if(startRoundPosEdge)       \n         begin\n            p_bit_count <= 0;\n \t    p_pt <= 0; // Tony D. 04/02/20 Need to reset this hting else getting X in vector capture\t       \n         end\n//       else\n       else if ( code_gen_en) begin     // tony D.\n         begin\n            if(p_bit_count < 8'd128)\n              begin\n                 p_bit_count <= p_bit_count + 1;\n                 p_pt <= {p_pt [126:0], p_code_bit};\n              end\n         end\n       end\n    end // always @ (posedge gps_clk_fast)\n   \n\nassign p_code = p_pt;\n\nreg encrypt;\nalways @(posedge gps_clk_fast)\n  begin\n     if (sync_rst_in) encrypt <= 0; // Added TOny D.\n     else begin\n        encrypt <= 0;\n        if(p_bit_count == 8'd127)\n          encrypt <= 1'b1;\n     end\n  end\n   \n   //\n   // Tony Duong 05/12/2020: Even though CA-Code is transmitting at 10x slower then P/L-code, there is no reason why we need to compute\n   // the CA-Code with 10x slow clock as long as we can make timing...\n   //\n//`define USE_SLOW_CLOCK\n`ifdef USE_SLOW_CLOCK\n  gps_clkgen gps_clkgen_inst(\n    .sys_clk_50(sys_clk_50),\n    .sync_rst_in(sync_rst_in),\n\n    .gps_clk_fast(gps_clk_fast),\n    .gps_clk_slow(gps_clk_slow),\n    .gps_rst());\n`else\n   assign gps_clk_fast = sys_clk_50;\n   assign gps_clk_slow = sys_clk_50;\n`endif\n\n   //\n   // NOTE: key should be changed to input so they can be programmed to anything to reflect true usage\n   // TOny D. 05/12/20\n   //\n   // in order to remove the reset dependency, we need create a mask to mask out the out_valid from aes_192 module\n   // while computing CA-code and P-code, the valid is only applied when encryt=1\n   reg l_valid_mask;\n   wire l_code_valid_i;\n   assign l_code_valid = l_code_valid_i & l_valid_mask;\n   //\n   always @(posedge gps_clk_fast) begin\n      if (sync_rst_in)         l_valid_mask <= 0;\n      else if (codeGenPosEdge) l_valid_mask <= 0; // clear the mask\n      else if (encrypt)        l_valid_mask <= 1; // this happens             \n   end\n   //\n  aes_192 #(\n    .ROUNDS(10) // Default AES-192 uses 12 rounds\n  ) aes_192_inst (\n    .clk        (gps_clk_fast),\n    .rst        (sync_rst_in),\t\t\t\n    .start      (encrypt),\n    .state      (p_pt),\n    .key        (192'hAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA),\n    .out        (l_code),\n    .out_valid  (l_code_valid_i)\n  );\n\nendmodule\n"}, {"bug_id": 27, "cwe_id": "CWE-226", "description": "Sensitive Information in Resource Not Removed Before Reuse", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/gps/pcode_bug27.v", "verilog_content": "//************************************************************************\n// Copyright (C) 2020 Massachusetts Institute of Technology\n// SPDX short identifier: BSD-2-Clause\n//\n// File Name:      pcode.v\n// Program:        Common Evaluation Platform (CEP)\n// Description:    P-code generator\n//\n//************************************************************************\nmodule pcode(\n           clk, reset, prn_changed, en, sat,\n           preg,\n           keep_state\n       );\nparameter SAT_WIDTH = 6;\nparameter SREG_WIDTH = 37;\nparameter XREG_WIDTH = 12;\n//parameter PREG_WIDTH = 32;\nparameter ini_x1a=12'b001001001000;\nparameter ini_x1b=12'b010101010100;\nparameter ini_x2a=12'b100100100101;\nparameter ini_x2b=12'b010101010100;\n\n   input clk;\n   input reset;\n   input prn_changed;\n   \n   input en;\n   input [ SAT_WIDTH-1:0] sat;\n   input keep_state;\n`ifdef PREG_WIDTH\n   output reg [PREG_WIDTH-1:0] preg;\n`else\n   output reg \t\t       preg;\n`endif\n   \n   // Tony D.\n   wire    rst = reset | prn_changed;\n   \nreg[XREG_WIDTH-1:0] x1a;\nreg[XREG_WIDTH-1:0] x1b;\nreg[XREG_WIDTH-1:0] x2a;\nreg[XREG_WIDTH-1:0] x2b;\n//reg[SREG_WIDTH-1:0] sreg;\n   // sat is 1 based!!!\nreg [SREG_WIDTH:0] sreg; // tony duong 04/14/20 FIXME!!! sreg[sat] is used and gets X when sat=37\n\nwire x1a_rst, x1b_rst, x2a_rst, x2b_rst;\nwire x1a_cnt_d, x1b_cnt_d, x2a_cnt_d, x2b_cnt_d, x_cnt_d, z_cnt_eow, z_cnt_sow;\nreg[XREG_WIDTH-1:0] x1a_cnt, x1b_cnt, x2a_cnt, x2b_cnt;\nreg[SAT_WIDTH-1:0] x_cnt;\nreg[18:0] z_cnt;\n\nreg x1b_en, x2a_en, x2b_en;\nwire x1b_res, x2a_res, x2b_res;\nwire x1b_halt, x2a_halt, x2b_halt;\n\n//////////////////////////////////////////\n//Control Signals\n//////////////////////////////////////////\nassign x1b_res = x1a_cnt_d & x1a_rst;\nassign x1b_halt= x1b_cnt_d & x1b_rst;\n\nassign x2a_res = z_cnt_sow|x_cnt_d;\nassign x2a_halt= (z_cnt_eow|x2a_cnt_d) & x2a_rst;\n\nassign x2b_res = x2a_res;\nassign x2b_halt= (z_cnt_eow|x2b_cnt_d) & x2b_rst;\n\n//////////////////////////////////////////\n//Clock Control Signals\n//////////////////////////////////////////\nalways @(posedge clk)\n    begin\n        if(rst)\n            x1b_en<=1;\n        else if(en)\n            begin\n                if(x1b_halt)\n                    x1b_en<=0;\n                else if(x1b_res)\n                    x1b_en<=1;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2a_en<=1;\n        else if(en)\n            begin\n                if(x2a_halt)\n                    x2a_en<=0;\n                else if(x2a_res)\n                    x2a_en<=1;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2b_en<=1;\n        else if(en)\n            begin\n                if(x2b_halt)\n                    x2b_en<=0;\n                else if(x2b_res)\n                    x2b_en<=1;\n            end\n    end\n\n//////////////////////////////////////////\n//Decoders\n//////////////////////////////////////////\nassign x1a_rst = (x1a==12'd4092) ? 1:0;\nassign x1b_rst = (x1b==12'd4093) ? 1:0;\nassign x2a_rst = (x2a==12'd4092) ? 1:0;\nassign x2b_rst = (x2b==12'd4093) ? 1:0;\n\n//////////////////////////////////////////\n//Counters\n//////////////////////////////////////////\nassign x1a_cnt_d = (x1a_cnt==12'd3750)   ? 1:0;\nassign x1b_cnt_d = (x1b_cnt==12'd3749)   ? 1:0;\nassign x2a_cnt_d = (x2a_cnt==12'd3750)   ? 1:0;\nassign x2b_cnt_d = (x2b_cnt==12'd3749)   ? 1:0;\nassign x_cnt_d   = (x_cnt  ==6'd37)      ? 1:0;\nassign z_cnt_sow = ((z_cnt  ==19'd000000)& x1b_res==1) ? 1:0;\nassign z_cnt_eow = ((z_cnt  ==19'd403200)& x1b_res==1) ? 1:0;\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x1a_cnt  <=0;\n        else if(en & x1a_rst)\n            begin\n                if(x1a_cnt < 12'd3750)\n                    x1a_cnt <= x1a_cnt+1;\n                else\n                    x1a_cnt <= 12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x1b_cnt <=0;\n        else if(en &x1b_rst)\n            begin\n                if(x1b_cnt < 12'd3749)\n                    x1b_cnt <= x1b_cnt+1;\n                else\n                    x1b_cnt <= 12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2a_cnt<=0;\n        else if(en &x2a_rst)\n            begin\n                if(x2a_cnt < 12'd3750)\n                    x2a_cnt <= x2a_cnt+1;\n                else\n                    x2a_cnt <=12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2b_cnt  <=0;\n        else if(en &x2b_rst)\n            begin\n                if(x2b_cnt < 12'd3749)\n                    x2b_cnt <= x2b_cnt+1;\n                else\n                    x2b_cnt <=12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x_cnt<=0;\n        else if(en & x2a_res & x2a_cnt_d)\n            begin\n                if(x_cnt < 6'd37)\n                    x_cnt <= x_cnt+1;\n                else\n                    x_cnt <=19'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            z_cnt<=0;\n        else if(en & x1b_res)\n            begin\n                if(z_cnt < 19'd403200)\n                    z_cnt <= z_cnt+1;\n                else\n                    z_cnt <=19'd0;\n            end\n    end\n\n//////////////////////////////////////////\n//4 shift registers\n//////////////////////////////////////////\nalways @(posedge clk)\n    begin\n        if(rst|x1a_rst)\n            x1a<=ini_x1a;\n        else if(en)\n            x1a<={x1a[XREG_WIDTH-2:0],x1a[5]^x1a[7]^x1a[10]^x1a[11]};\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst|x1b_rst)\n            x1b<=ini_x1b;\n        else if (en & x1b_en)\n            x1b<={x1b[XREG_WIDTH-2:0],x1b[0]^x1b[1]^x1b[4]^x1b[7]^x1b[8]^x1b[9]^x1b[10]^x1b[11]};\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst|x2a_rst)\n            x2a<=ini_x2a;\n        else if (en & x2a_en)\n            x2a<={x2a[XREG_WIDTH-2:0],x2a[0]^x2a[2]^x2a[3]^x2a[4]^x2a[6]^x2a[7]^x2a[8]^x2a[9]^x2a[10]^x2a[11]};\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst|x2b_rst)\n            x2b<=ini_x2b;\n        else if (en & x2b_en)\n            x2b<={x2b[XREG_WIDTH-2:0],x2b[1]^x2b[2]^x2b[3]^x2b[7]^x2b[8]^x2b[11]};\n    end\n\n//Output\nalways @(posedge clk) begin\n    if (rst && !keep_state) begin\n        sreg <= 38'b0; // SREG_WIDTH=37, so 38 bits\n    end else if (en) begin\n        sreg <= {sreg[SREG_WIDTH-1:0], (x2a[XREG_WIDTH-1] ^ x2b[XREG_WIDTH-1])};\n    end\nend\n\nalways @(posedge clk)\n    begin\n        if(rst)\n`ifdef PREG_WIDTH\n\n            preg<=32'b0;\n`else\n            preg<=1'b0;\n`endif\n\n        else if(en)\n`ifdef PREG_WIDTH\n\n            preg<={preg[PREG_WIDTH-2:0],(x1a[XREG_WIDTH-1]^x1b[XREG_WIDTH-1])^sreg[sat]};\n`else\n            preg<={(x1a[XREG_WIDTH-1]^x1b[XREG_WIDTH-1])^sreg[sat]};\n`endif\n\n    end\n\nendmodule\n"}, {"bug_id": 31, "cwe_id": "CWE-440", "description": "Expected Behavior Violation", "filename": "/Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/gps/pcode_bug31.v", "verilog_content": "//************************************************************************\n// Copyright (C) 2020 Massachusetts Institute of Technology\n// SPDX short identifier: BSD-2-Clause\n//\n// File Name:      pcode.v\n// Program:        Common Evaluation Platform (CEP)\n// Description:    P-code generator\n//\n//************************************************************************\nmodule pcode(\n           clk, reset, prn_changed, en, sat,\n           preg\n       );\nparameter SAT_WIDTH = 6;\nparameter SREG_WIDTH = 37;\nparameter XREG_WIDTH = 12;\n//parameter PREG_WIDTH = 32;\nparameter ini_x1a=12'b001001001000;\nparameter ini_x1b=12'b010101010100;\nparameter ini_x2a=12'b100100100101;\nparameter ini_x2b=12'b010101010100;\n\n   input clk;\n   input reset;\n   input prn_changed;\n   \n   input en;\n   input [ SAT_WIDTH-1:0] sat;\n`ifdef PREG_WIDTH\n   output reg [PREG_WIDTH-1:0] preg;\n`else\n   output reg \t\t       preg;\n`endif\n   \n   // Tony D.\n   wire    rst = reset | prn_changed;\n   \nreg[XREG_WIDTH-1:0] x1a;\nreg[XREG_WIDTH-1:0] x1b;\nreg[XREG_WIDTH-1:0] x2a;\nreg[XREG_WIDTH-1:0] x2b;\n//reg[SREG_WIDTH-1:0] sreg;\n   // sat is 1 based!!!\nreg [SREG_WIDTH:0] sreg; // tony duong 04/14/20 FIXME!!! sreg[sat] is used and gets X when sat=37\n\nwire x1a_rst, x1b_rst, x2a_rst, x2b_rst;\nwire x1a_cnt_d, x1b_cnt_d, x2a_cnt_d, x2b_cnt_d, x_cnt_d, z_cnt_eow, z_cnt_sow;\nreg[XREG_WIDTH-1:0] x1a_cnt, x1b_cnt, x2a_cnt, x2b_cnt;\nreg[SAT_WIDTH-1:0] x_cnt;\nreg[18:0] z_cnt;\n\nreg x1b_en, x2a_en, x2b_en;\nwire x1b_res, x2a_res, x2b_res;\nwire x1b_halt, x2a_halt, x2b_halt;\n\n//////////////////////////////////////////\n//Control Signals\n//////////////////////////////////////////\nassign x1b_res = x1a_cnt_d & x1a_rst;\nassign x1b_halt= x1b_cnt_d & x1b_rst;\n\nassign x2a_res = z_cnt_sow|x_cnt_d;\nassign x2a_halt= (z_cnt_eow|x2a_cnt_d) & x2a_rst;\n\nassign x2b_res = x2a_res;\nassign x2b_halt= (z_cnt_eow|x2b_cnt_d) & x2b_rst;\n\n//////////////////////////////////////////\n//Clock Control Signals\n//////////////////////////////////////////\nalways @(posedge clk)\n    begin\n        if(rst)\n            x1b_en<=1;\n        else if(en)\n            begin\n                if(x1b_halt)\n                    x1b_en<=0;\n                else if(x1b_res)\n                    x1b_en<=1;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2a_en<=1;\n        else if(en)\n            begin\n                if(x2a_halt)\n                    x2a_en<=0;\n                else if(x2a_res)\n                    x2a_en<=1;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2b_en<=1;\n        else if(en)\n            begin\n                if(x2b_halt)\n                    x2b_en<=0;\n                else if(x2b_res)\n                    x2b_en<=1;\n            end\n    end\n\n//////////////////////////////////////////\n//Decoders\n//////////////////////////////////////////\nassign x1a_rst = (x1a==12'd4092) ? 1:0;\nassign x1b_rst = (x1b==12'd4093) ? 1:0;\nassign x2a_rst = (x2a==12'd4092) ? 1:0;\nassign x2b_rst = (x2b==12'd4093) ? 1:0;\n\n//////////////////////////////////////////\n//Counters\n//////////////////////////////////////////\nassign x1a_cnt_d = (x1a_cnt==12'd3750)   ? 1:0;\nassign x1b_cnt_d = (x1b_cnt==12'd3749)   ? 1:0;\nassign x2a_cnt_d = (x2a_cnt==12'd3750)   ? 1:0;\nassign x2b_cnt_d = (x2b_cnt==12'd3749)   ? 1:0;\nassign x_cnt_d   = (x_cnt  ==6'd37)      ? 1:0;\nassign z_cnt_sow = ((z_cnt  ==19'd000000)& x1b_res==1) ? 1:0;\nassign z_cnt_eow = ((z_cnt  ==19'd403200)& x1b_res==1) ? 1:0;\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x1a_cnt  <=0;\n        else if(en & x1a_rst)\n            begin\n                if(x1a_cnt < 12'd3750)\n                    x1a_cnt <= x1a_cnt+1;\n                else\n                    x1a_cnt <= 12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x1b_cnt <=0;\n        else if(en &x1b_rst)\n            begin\n                if(x1b_cnt < 12'd3749)\n                    x1b_cnt <= x1b_cnt+1;\n                else\n                    x1b_cnt <= 12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2a_cnt<=0;\n        else if(en &x2a_rst)\n            begin\n                if(x2a_cnt < 12'd3750)\n                    x2a_cnt <= x2a_cnt+1;\n                else\n                    x2a_cnt <=12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x2b_cnt  <=0;\n        else if(en &x2b_rst)\n            begin\n                if(x2b_cnt < 12'd3749)\n                    x2b_cnt <= x2b_cnt+1;\n                else\n                    x2b_cnt <=12'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            x_cnt<=0;\n        else if(en & x2a_res & x2a_cnt_d)\n            begin\n                if(x_cnt < 6'd37)\n                    x_cnt <= x_cnt+1;\n                else\n                    x_cnt <=19'd0;\n            end\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n            z_cnt<=0;\n        else if(en & x1b_res)\n            begin\n                if(z_cnt < 19'd403200)\n                    z_cnt <= z_cnt+1;\n                else\n                    z_cnt <=19'd0;\n            end\n    end\n\n//////////////////////////////////////////\n//4 shift registers\n//////////////////////////////////////////\nalways @(posedge clk)\n    begin\n        if(rst|x1a_rst)\n            x1a<=ini_x1a;\n        else if(en)\n            x1a<={x1a[XREG_WIDTH-2:0], x1a[4] ^ x1a[6] ^ x1a[9] ^ x1a[10]}; // Altered taps\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst|x1b_rst)\n            x1b<=ini_x1b;\n        else if (en & x1b_en)\n            x1b<={x1b[XREG_WIDTH-2:0],x1b[0]^x1b[1]^x1b[4]^x1b[7]^x1b[8]^x1b[9]^x1b[10]^x1b[11]};\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst|x2a_rst)\n            x2a<=ini_x2a;\n        else if (en & x2a_en)\n            x2a<={x2a[XREG_WIDTH-2:0],x2a[0]^x2a[2]^x2a[3]^x2a[4]^x2a[6]^x2a[7]^x2a[8]^x2a[9]^x2a[10]^x2a[11]};\n    end\n\nalways @(posedge clk)\n    begin\n        if(rst|x2b_rst)\n            x2b<=ini_x2b;\n        else if (en & x2b_en)\n            x2b<={x2b[XREG_WIDTH-2:0],x2b[1]^x2b[2]^x2b[3]^x2b[7]^x2b[8]^x2b[11]};\n    end\n\n//Output\nalways @(posedge clk)\n    begin\n        if(rst)\n            sreg<=32'b0;\n        else if(en)\n//            sreg<={sreg[SREG_WIDTH-2:0],(x2a[XREG_WIDTH-1]^x2b[XREG_WIDTH-1])};\n\t  // tony D, sat is 1-based\n          sreg<={sreg[SREG_WIDTH-1:0],(x2a[XREG_WIDTH-1]^x2b[XREG_WIDTH-1])};\t  \n    end\n\nalways @(posedge clk)\n    begin\n        if(rst)\n`ifdef PREG_WIDTH\n\n            preg<=32'b0;\n`else\n            preg<=1'b0;\n`endif\n\n        else if(en)\n`ifdef PREG_WIDTH\n\n            preg<={preg[PREG_WIDTH-2:0],(x1a[XREG_WIDTH-1]^x1b[XREG_WIDTH-1])^sreg[sat]};\n`else\n            preg<={(x1a[XREG_WIDTH-1]^x1b[XREG_WIDTH-1])^sreg[sat]};\n`endif\n\n    end\n\nendmodule\n"}]