{"prompt": "You are an expert in hardware security.\nGenerate a new RTL example that exhibits a security bug similar to the following examples.\n\nCWE CWE-325: Missing Cryptographic Step\n```verilog\n/*\n * Copyright 2012, Homer Hsing <homer.hsing@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* verilator lint_off UNOPTFLAT */\n\n/* one AES round for every two clock cycles */\nmodule one_round (clk, rst, state_in, key, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in, key;\noutput reg [127:0] state_out;\nwire       [31:0]  s0,  s1,  s2,  s3,\n           z0,  z1,  z2,  z3,\n           p00, p01, p02, p03,\n           p10, p11, p12, p13,\n           p20, p21, p22, p23,\n           p30, p31, p32, p33,\n           k0,  k1,  k2,  k3;\n\nassign {k0, k1, k2, k3} = key;\n\nassign {s0, s1, s2, s3} = state_in;\n\ntable_lookup\n    t0 (clk, rst, s0, p00, p01, p02, p03),\n    t1 (clk, rst, s1, p10, p11, p12, p13),\n    t2 (clk, rst, s2, p20, p21, p22, p23),\n    t3 (clk, rst, s3, p30, p31, p32, p33);\n\nassign z0 = p00 ^ p11 ^ p22 ^ p33 ^ k0;\nassign z1 = p03 ^ p10 ^ p21 ^ p32 ^ k1;\nassign z2 = p02 ^ p13 ^ p20 ^ p31 ^ k2;\nassign z3 = p01 ^ p12 ^ p23 ^ p30 ^ k3;\n\nalways @ (posedge clk)\n    state_out <= {z0, z1, z2, z3};\nendmodule\n\n    /* AES final round for every two clock cycles */\n    module final_round (clk, rst, state_in, key_in, state_out);\ninput              clk;\ninput              rst;\ninput      [127:0] state_in;\ninput      [127:0] key_in;\noutput reg [127:0] state_out;\nwire [31:0] s0,  s1,  s2,  s3,\n     z0,  z1,  z2,  z3,\n     k0,  k1,  k2,  k3;\nwire [7:0]  p00, p01, p02, p03,\n     p10, p11, p12, p13,\n     p20, p21, p22, p23,\n     p30, p31, p32, p33;\n\nassign {k0, k1, k2, k3} = key_in;\n\nassign {s0, s1, s2, s3} = state_in;\n\nS4\n    S4_1 (clk, rst, s0, {p00, p01, p02, p03}),\n    S4_2 (clk, rst, s1, {p10, p11, p12, p13}),\n    S4_3 (clk, rst, s2, {p20, p21, p22, p23}),\n    S4_4 (clk, rst, s3, {p30, p31, p32, p33});\n\nassign z0 = {p00, p11, p22, p33} ^ k0;\nassign z1 = {p10, p21, p32, p03} ^ k1;\nassign z2 = {p20, p31, p02, p13} ^ k2;\nassign z3 = {p30, p01, p12, p23} ^ k3;\n\nalways @ (posedge clk)\n    if (rst)\n      state_out <= 0;\n    else\n      state_out <= {z0, z1, z2, z3};\nendmodule\n\nmodule one_round_skip (clk, rst, state_in, key, state_out);\n    input clk, rst;\n    input [127:0] state_in, key;\n    output reg [127:0] state_out;\n    always @ (posedge clk)\n        if (rst)\n            state_out <= 0;\n        else\n            state_out <= state_in; // Simply passes input to output\nendmodule\n\n```\nBug location: /Users/agastya/Library/Mobile Documents/com~apple~CloudDocs/Downloads/cep-cwe-benchmark/hdl_cores/aes/round_bug7.v\n\nGenerate a new Verilog module with a similar security vulnerability.\n\nIMPORTANT: Follow this EXACT output format:\n```verilog\nmodule example_module(\n    input wire clk,\n    input wire rst_n\n);\n    // Your Verilog code here\n    // BUG: [brief description of the vulnerability]\n    // The bug should be similar to the examples above\nendmodule\n```\n\nRequirements:\n1. Output ONLY the Verilog code block (no explanations outside the code)\n2. Include a clear comment starting with '// BUG:' to mark the vulnerability location\n3. Make the vulnerability realistic and similar to the CWE examples shown\n4. Use proper Verilog syntax with module declaration\n5. Keep the code concise but complete enough to demonstrate the security issue\n6. Ensure the bug comment is on its own line for easy parsing\n\nReturn the Verilog code block only.", "completion": "```verilog\nmodule example_module(\n    input wire clk,\n    input wire rst_n,\n    input wire [127:0] data_in,\n    input wire [127:0] key_in,\n    output reg [127:0] data_out\n);\n    reg [127:0] temp_data;\n    wire [127:0] round_key;\n    \n    assign round_key = key_in;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            temp_data <= 128'b0;\n        else\n            temp_data <= data_in ^ round_key; // Incomplete cryptographic processing\n    end\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 128'b0;\n        else\n            data_out <= temp_data;\n    end\n\n    // BUG: Missing critical cryptographic transformation step, leaving data vulnerable\nendmodule\n```", "verilog_code": "module example_module(\n    input wire clk,\n    input wire rst_n,\n    input wire [127:0] data_in,\n    input wire [127:0] key_in,\n    output reg [127:0] data_out\n);\n    reg [127:0] temp_data;\n    wire [127:0] round_key;\n    \n    assign round_key = key_in;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            temp_data <= 128'b0;\n        else\n            temp_data <= data_in ^ round_key; // Incomplete cryptographic processing\n    end\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 128'b0;\n        else\n            data_out <= temp_data;\n    end\n\n    // BUG: Missing critical cryptographic transformation step, leaving data vulnerable\nendmodule", "bug_location": "// BUG: Missing critical cryptographic transformation step, leaving data vulnerable"}
